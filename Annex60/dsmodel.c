/* DSblock model generated by Dymola from Modelica model Annex60.Experimental.Benchmarks.CentralHeatingSystem.System1
 Dymola Version 2015 (32-bit), 2014-04-11 translated this at Tue Oct 28 10:29:30 2014

   */

#include <matrixop.h>
static double DymArrays0[1]={0.0};
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc1;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
struct DymStruc1 {
  RealArray   r_V_0member;
  RealArray   eta_0member;
};
DYMOLA_STATIC struct DymStruc1 DymStruc1_construct(RealArray    eta_02, 
  RealArray    r_V_02) {
  struct DymStruc1 dummy_0;
  dummy_0.eta_0member = eta_02;
  dummy_0.r_V_0member = r_V_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, double  dpx_0der, 
  double  kx_0der, double  mx_0flowx_0turbulentx_0der);
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der, double  kx_0der, double  mx_0flowx_0turbulentx_0der);
DYMOLA_STATIC double   Annex60_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc1 data0_0, double  rx_0V, RealArray   d0_0);
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_BaseClasses_derx_0regNonZeroPower
  (double  x0_0, double  n0_0, double  delta0_0, double  derx_0x);
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0);
DYMOLA_STATIC int   Annex60_Utilities_Math_Functions_isMonotonic(RealArray   
  x0_0, int  strict0_0);
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_powerLinearized(double  
  x0_0, double  n0_0, double  x00_0);
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_regNonZeroPower(double  
  x0_0, double  n0_0, double  delta0_0);
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_spliceFunction(double  
  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0, double  derx_0u);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2(double  x0_0, double  
  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
/* Codes used in model */

/* Flattened Modelica model:

function Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp
discrete input Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
discrete input Real k(min = 0.0) "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate";
discrete output Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
protected 
discrete Real dp_turbulent(unit = "Pa", displayUnit = "Pa") "Turbulent flow if |dp| >= dp_small, not a parameter because k can be a function of time";
discrete Real kSqu(unit = "kg.m") "Flow coefficient, kSqu=k^2=m_flow^2/|dp|";
public 
algorithm 
kSqu := k*k;
dp_turbulent := m_flow_turbulent^2/kSqu;
m_flow := Modelica.Fluid.Utilities.regRoot2(dp, dp_turbulent, kSqu, kSqu, false, 1);
annotation(derivative=Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der, LateInline=true, smoothOrder=2);
end Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp;

  */
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dpx_0turbulent;
    double   kSqu0_0;
    mx_0flow=0;
    dpx_0turbulent=0;
    kSqu0_0=0;
    /* Start of real code */
      kSqu0_0 = k0_0*k0_0;
      dpx_0turbulent = divmacro(sqr(mx_0flowx_0turbulent),"m_flow_turbulent^2",
        kSqu0_0,"kSqu");
      mx_0flow = Modelica_Fluid_Utilities_regRoot2(dp0_0, dpx_0turbulent, 
        kSqu0_0, kSqu0_0, false, 1);
    /* Output section */
    PopContext()
    return mx_0flow;
  }}

/* Flattened Modelica model:

function Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der
discrete input Real dp;
discrete input Real k;
discrete input Real m_flow_turbulent;
protected 
discrete Real m_flow;
discrete Real dp_turbulent;
discrete Real kSqu;
public 
discrete input Real dp_der;
discrete input Real k_der;
discrete input Real m_flow_turbulent_der;
discrete output Real m_flow_der;
protected 
discrete Real dp_turbulent_der;
discrete Real kSqu_der;
public 
algorithm 
kSqu_der := 2.0*(k_der*k);
kSqu := k*k;
dp_turbulent_der := 2.0*(m_flow_turbulent*m_flow_turbulent_der)/kSqu-m_flow_turbulent^2*kSqu_der/kSqu^2;
dp_turbulent := m_flow_turbulent^2/kSqu;
m_flow_der := Modelica.Fluid.Utilities.regRoot2:der(dp, dp_turbulent, kSqu, kSqu, false, 1, dp_der, dp_turbulent_der, kSqu_der, kSqu_der, 0);
annotation(derivative=Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der:derf, smoothOrder=1);
end Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der;

  */
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, double  dpx_0der, 
  double  kx_0der, double  mx_0flowx_0turbulentx_0der) {
  PushContext("Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dpx_0turbulent;
    double   kSqu0_0;
    double   mx_0flowx_0der;
    double   dpx_0turbulentx_0der;
    double   kSqux_0der;
    mx_0flow=0;
    dpx_0turbulent=0;
    kSqu0_0=0;
    mx_0flowx_0der=0;
    dpx_0turbulentx_0der=0;
    kSqux_0der=0;
    /* Start of real code */
      kSqux_0der = 2.0*kx_0der*k0_0;
      kSqu0_0 = k0_0*k0_0;
      dpx_0turbulentx_0der = divmacro(2.0*mx_0flowx_0turbulent*mx_0flowx_0turbulentx_0der,
        "2.0*(m_flow_turbulent*m_flow_turbulent_der)",kSqu0_0,"kSqu")-divmacro(
        sqr(mx_0flowx_0turbulent)*kSqux_0der,"m_flow_turbulent^2*kSqu_der",sqr(
        kSqu0_0),"kSqu^2");
      dpx_0turbulent = divmacro(sqr(mx_0flowx_0turbulent),"m_flow_turbulent^2",
        kSqu0_0,"kSqu");
      mx_0flowx_0der = Modelica_Fluid_Utilities_regRoot2__der(dp0_0, 
        dpx_0turbulent, kSqu0_0, kSqu0_0, false, 1, dpx_0der, dpx_0turbulentx_0der,
         kSqux_0der, kSqux_0der, 0);
    /* Output section */
    PopContext()
    return mx_0flowx_0der;
  }}

/* Flattened Modelica model:

function Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real kSquInv(unit = "1/(kg.m)") "Flow coefficient";
public 
algorithm 
kSquInv := 1/k^2;
dp := Modelica.Fluid.Utilities.regSquare2(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1);
annotation(derivative=Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der, LateInline=true, smoothOrder=2);
end Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    dp0_0=0;
    kSquInv0_0=0;
    /* Start of real code */
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dp0_0 = Modelica_Fluid_Utilities_regSquare2(mx_0flow, mx_0flowx_0turbulent,
         kSquInv0_0, kSquInv0_0, false, 1);
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der
discrete input Real m_flow;
discrete input Real k;
discrete input Real m_flow_turbulent;
protected 
discrete Real dp;
discrete Real kSquInv;
public 
discrete input Real m_flow_der;
discrete input Real k_der;
discrete input Real m_flow_turbulent_der;
discrete output Real dp_der;
protected 
discrete Real kSquInv_der;
public 
algorithm 
kSquInv_der :=  -2.0*(k*k_der)/(k^2)^2;
kSquInv := 1/k^2;
dp_der := Modelica.Fluid.Utilities.regSquare2:der(m_flow, m_flow_turbulent, kSquInv, kSquInv, false, 1, m_flow_der, m_flow_turbulent_der, kSquInv_der, kSquInv_der, 0);
annotation(derivative=Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der:derf, smoothOrder=1);
end Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der;

  */
DYMOLA_STATIC double   Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der, double  kx_0der, double  mx_0flowx_0turbulentx_0der) {
  PushContext("Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    double   dpx_0der;
    double   kSquInvx_0der;
    dp0_0=0;
    kSquInv0_0=0;
    dpx_0der=0;
    kSquInvx_0der=0;
    /* Start of real code */
      kSquInvx_0der =  -divmacro(2.0*k0_0*kx_0der,"2.0*(k*k_der)",sqr(sqr(k0_0)),
        "(k^2)^2");
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      dpx_0der = Modelica_Fluid_Utilities_regSquare2__der(mx_0flow, 
        mx_0flowx_0turbulent, kSquInv0_0, kSquInv0_0, false, 1, mx_0flowx_0der, 
        mx_0flowx_0turbulentx_0der, kSquInvx_0der, kSquInvx_0der, 0);
    /* Output section */
    PopContext()
    return dpx_0der;
  }}

/* Flattened Modelica model:

function Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency
parameter input Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters data;
discrete input Real r_V(unit = "1") "Volumetric flow rate divided by nominal flow rate";
discrete input Real d[:] "Derivatives at support points for spline interpolation";
discrete output Real eta(unit = "1", min = 0.0) "Efficiency";
protected 
Integer n(start = size(data.r_V, 1)) "Number of data points";
Integer i "Integer to select data interval";
public 
algorithm 
if (n == 1) then 
eta := data.eta[1];
else
i := 1;
for j in (1:n-1) loop
if (r_V > data.r_V[j]) then 
i := j;
end if;
end for;
eta := Annex60.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(r_V, data.r_V[i], data.r_V[i+1], data.eta[i], data.eta[i+1], d[i], d[i+1]);
end if;
annotation(smoothOrder=1);
end Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency;

  */
DYMOLA_STATIC double   Annex60_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc1 data0_0, double  rx_0V, RealArray   d0_0) {
  PushContext("Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = RealSize( data0_0.r_V_0member, 1);
    i0_0=0;
    /* Start of real code */
      if (n0_0 == 1) {
        eta0_0 = RealVectorElement( data0_0.eta_0member, (SizeType)(1));
      }
      else{
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rx_0V > RealElement( data0_0.r_V_0member, (SizeType)(j0_0_0))) {
              i0_0 = j0_0_0;
            }
          }
        }
        eta0_0 = Annex60_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
          (rx_0V, RealElement( data0_0.r_V_0member, (SizeType)(i0_0)), 
          RealElement( data0_0.r_V_0member, (SizeType)(i0_0+1)), RealElement( 
          data0_0.eta_0member, (SizeType)(i0_0)), RealElement( data0_0.
          eta_0member, (SizeType)(i0_0+1)), RealElement( d0_0, (SizeType)(i0_0)),
           RealElement( d0_0, (SizeType)(i0_0+1)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return eta0_0;
  }}

/* Flattened Modelica model:

function Annex60.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower
discrete input Real x "Abscissa value";
discrete input Real n "Exponent";
discrete input Real delta(start = 0.01) "Abscissa value where transition occurs";
discrete input Real der_x;
discrete output Real der_y "Function value";
protected 
discrete Real a1;
discrete Real a3;
discrete Real delta2;
discrete Real x2;
discrete Real y_d "=y(delta)";
discrete Real yP_d "=dy(delta)/dx";
discrete Real yPP_d "=d^2y(delta)/dx^2";
public 
algorithm 
if (abs(x) > delta) then 
der_y := noEvent((if x > 0 then 1 else (if x < 0 then -1 else 0)))*n*abs(x)^(n-1);
else
delta2 := delta*delta;
x2 := x*x;
y_d := delta^n;
yP_d := n*delta^(n-1);
yPP_d := n*(n-1)*delta^(n-2);
a1 :=  -(yP_d/delta-yPP_d)/delta2/8;
a3 := (yPP_d-12*a1*delta2)/2;
der_y := x*(4*a1*x*x+2*a3);
end if;
annotation(derivative(zeroDerivative=delta, zeroDerivative=n)=Annex60.Utilities.Math.Functions.BaseClasses.der_2_regNonZeroPower);
end Annex60.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower;

  */
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_BaseClasses_derx_0regNonZeroPower
  (double  x0_0, double  n0_0, double  delta0_0, double  derx_0x) {
  PushContext("Annex60.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower")
  {
    /* Declare outputs and temporaries */
    double   derx_0y;
    double   a10_0;
    double   a30_0;
    double   delta20_0;
    double   x20_0;
    double   yx_0d;
    double   yPx_0d;
    double   yPPx_0d;
    derx_0y=0;
    a10_0=0;
    a30_0=0;
    delta20_0=0;
    x20_0=0;
    yx_0d=0;
    yPx_0d=0;
    yPPx_0d=0;
    /* Start of real code */
      if (fabs(x0_0) > delta0_0) {
        derx_0y = (IF x0_0 > 0 THEN 1 ELSE IF x0_0 < 0 THEN -1 ELSE 0)*n0_0*
          powmacro(fabs(x0_0),"abs(x)",n0_0-1,"n-1");
      }
      else{
        delta20_0 = delta0_0*delta0_0;
        x20_0 = x0_0*x0_0;
        yx_0d = powmacro(delta0_0,"delta",n0_0,"n");
        yPx_0d = n0_0*powmacro(delta0_0,"delta",n0_0-1,"n-1");
        yPPx_0d = n0_0*(n0_0-1)*powmacro(delta0_0,"delta",n0_0-2,"n-2");
        a10_0 =  -divmacro(divmacro(yPx_0d,"yP_d",delta0_0,"delta")-yPPx_0d,
          "yP_d/delta-yPP_d",delta20_0,"delta2")/(double)(8);
        a30_0 = (yPPx_0d-12*a10_0*delta20_0)/(double)(2);
        derx_0y = x0_0*(4*a10_0*x0_0*x0_0+2*a30_0);
      }
    /* Output section */
    PopContext()
    return derx_0y;
  }}

/* Flattened Modelica model:

function Annex60.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";

algorithm 
if (x > x1 and x < x2) then 
y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
elseif (x <= x1) then 
y := y1+(x-x1)*y1d;
else
y := y2+(x-x2)*y2d;
end if;
annotation(smoothOrder=1);
end Annex60.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

  */
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0) {
  PushContext("Annex60.Utilities.Math.Functions.cubicHermiteLinearExtrapolation")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        y0_0 = Modelica_Fluid_Utilities_cubicHermite(x0_0, x10_0, x20_0, y10_0, 
          y20_0, y1d0_0, y2d0_0);
      }
      else if (x0_0 <= x10_0) {
        y0_0 = y10_0+(x0_0-x10_0)*y1d0_0;
      }
      else{
        y0_0 = y20_0+(x0_0-x20_0)*y2d0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Annex60.Utilities.Math.Functions.isMonotonic
discrete input Real x[:] "Sequence to be tested";
input Boolean strict(start = false) "Set to true to test for strict monotonicity";
output Boolean monotonic "True if x is monotonic increasing or decreasing";
protected 
Integer n(start = size(x, 1)) "Number of data points";
public 
algorithm 
if (n == 1) then 
monotonic := true;
else
monotonic := true;
if (strict) then 
if (x[1] >= x[n]) then 
for i in (1:n-1) loop
if ( not (x[i] > x[i+1])) then 
monotonic := false;
end if;
end for;
else
for i in (1:n-1) loop
if ( not (x[i] < x[i+1])) then 
monotonic := false;
end if;
end for;
end if;
else
if (x[1] >= x[n]) then 
for i in (1:n-1) loop
if ( not (x[i] >= x[i+1])) then 
monotonic := false;
end if;
end for;
else
for i in (1:n-1) loop
if ( not (x[i] <= x[i+1])) then 
monotonic := false;
end if;
end for;
end if;
end if;
end if;
end Annex60.Utilities.Math.Functions.isMonotonic;

  */
DYMOLA_STATIC int   Annex60_Utilities_Math_Functions_isMonotonic(RealArray   
  x0_0, int  strict0_0) {
  PushContext("Annex60.Utilities.Math.Functions.isMonotonic")
  {
    /* Declare outputs and temporaries */
    int   monotonic0_0;
    int   n0_0;
    MarkObject retmark_ = PushMark();
    monotonic0_0=0;
    n0_0 = RealSize( x0_0, 1);
    /* Start of real code */
      if (n0_0 == 1) {
        monotonic0_0 = true;
      }
      else{
        monotonic0_0 = true;
        if (strict0_0) {
          if (RealVectorElement( x0_0, (SizeType)(1)) >= RealElement( x0_0, 
            (SizeType)(n0_0))) {
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) > RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
          else{
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) < RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
        }
        else{
          if (RealVectorElement( x0_0, (SizeType)(1)) >= RealElement( x0_0, 
            (SizeType)(n0_0))) {
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) >= RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
          else{
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) <= RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return monotonic0_0;
  }}

/* Flattened Modelica model:

function Annex60.Utilities.Math.Functions.powerLinearized
discrete input Real x "Abscissa value";
discrete input Real n "Exponent";
discrete input Real x0 "Abscissa value below which linearization occurs";
discrete output Real y "Function value";

algorithm 
if (x > x0) then 
y := x^n;
else
y := x0^n*(1-n)+n*x0^(n-1)*x;
end if;
annotation(Inline=true, smoothOrder=1);
end Annex60.Utilities.Math.Functions.powerLinearized;

  */
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_powerLinearized(double  
  x0_0, double  n0_0, double  x00_0) {
  PushContext("Annex60.Utilities.Math.Functions.powerLinearized")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x00_0) {
        y0_0 = powmacro(x0_0,"x",n0_0,"n");
      }
      else{
        y0_0 = powmacro(x00_0,"x0",n0_0,"n")*(1-n0_0)+n0_0*powmacro(x00_0,"x0",
          n0_0-1,"n-1")*x0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Annex60.Utilities.Math.Functions.regNonZeroPower
discrete input Real x "Abscissa value";
discrete input Real n "Exponent";
discrete input Real delta(start = 0.01) "Abscissa value where transition occurs";
discrete output Real y "Function value";
protected 
discrete Real a1;
discrete Real a3;
discrete Real a5;
discrete Real delta2;
discrete Real x2;
discrete Real y_d "=y(delta)";
discrete Real yP_d "=dy(delta)/dx";
discrete Real yPP_d "=d^2y(delta)/dx^2";
public 
algorithm 
if (abs(x) > delta) then 
y := abs(x)^n;
else
delta2 := delta*delta;
x2 := x*x;
y_d := delta^n;
yP_d := n*delta^(n-1);
yPP_d := n*(n-1)*delta^(n-2);
a1 :=  -(yP_d/delta-yPP_d)/delta2/8;
a3 := (yPP_d-12*a1*delta2)/2;
a5 := y_d-delta2*(a3+delta2*a1);
y := a5+x2*(a3+x2*a1);
assert(a5 > 0, "Delta is too small for this exponent.");
end if;
annotation(derivative(zeroDerivative=delta, zeroDerivative=n)=Annex60.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower, Inline=true, smoothOrder=2);
end Annex60.Utilities.Math.Functions.regNonZeroPower;

  */
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_regNonZeroPower(double  
  x0_0, double  n0_0, double  delta0_0) {
  PushContext("Annex60.Utilities.Math.Functions.regNonZeroPower")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a30_0;
    double   a50_0;
    double   delta20_0;
    double   x20_0;
    double   yx_0d;
    double   yPx_0d;
    double   yPPx_0d;
    y0_0=0;
    a10_0=0;
    a30_0=0;
    a50_0=0;
    delta20_0=0;
    x20_0=0;
    yx_0d=0;
    yPx_0d=0;
    yPPx_0d=0;
    /* Start of real code */
      if (fabs(x0_0) > delta0_0) {
        y0_0 = powmacro(fabs(x0_0),"abs(x)",n0_0,"n");
      }
      else{
        delta20_0 = delta0_0*delta0_0;
        x20_0 = x0_0*x0_0;
        yx_0d = powmacro(delta0_0,"delta",n0_0,"n");
        yPx_0d = n0_0*powmacro(delta0_0,"delta",n0_0-1,"n-1");
        yPPx_0d = n0_0*(n0_0-1)*powmacro(delta0_0,"delta",n0_0-2,"n-2");
        a10_0 =  -divmacro(divmacro(yPx_0d,"yP_d",delta0_0,"delta")-yPPx_0d,
          "yP_d/delta-yPP_d",delta20_0,"delta2")/(double)(8);
        a30_0 = (yPPx_0d-12*a10_0*delta20_0)/(double)(2);
        a50_0 = yx_0d-delta20_0*(a30_0+delta20_0*a10_0);
        y0_0 = a50_0+x20_0*(a30_0+x20_0*a10_0);
        AssertModelica(a50_0 > 0,"a5 > 0", "Delta is too small for this exponent.");
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Annex60.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=Annex60.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end Annex60.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   Annex60_Utilities_Math_Functions_spliceFunction(double  
  pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("Annex60.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = RealSize( crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( cr0_0, (SizeType)(i0_0_0)), r0_0, 
            (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement( -RealElement( c10_0, (SizeType)(i0_0_0))/(double)(2), 
            a0_0, (SizeType)(i0_0_0));
          SetRealElement(sqrtGuarded(RealElement( c00_0, (SizeType)(i0_0_0))-
            RealElement( a0_0, (SizeType)(i0_0_0))*RealElement( a0_0, (SizeType)
            (i0_0_0)),"c0[i]-a[i]*a[i]"), b0_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(RealElement( c00_0, (SizeType)(i0_0_0)),
            "c0[i]",RealElement( b0_0, (SizeType)(i0_0_0)),"b[i]"), ku0_0, 
            (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getDerTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete input Real der_u;
discrete output Real der_y;

external "C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getDerTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0, double  derx_0u) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getDerTableValue")
  {
    /* Declare outputs and temporaries */
    double   derx_0y;
    derx_0y=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_getDerValue)(void*, int ,
         double , double );
      derx_0y = (ModelicaStandardTables_CombiTable1D_getDerValue)(
        externalTable_[tableID0_0.id_0member].obj_, icol0_0, u0_0, derx_0u);
      }
    /* Output section */
    PopContext()
    return derx_0y;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1D.getDerTableValue, Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.getTableValue;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , 
        double );
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1D.readTableData
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Boolean forceRead(start = false) "= true: Force reading of table data; = false: Only read, if not yet read.";
input Boolean verboseRead "= true: Print info message; = false: No info message";
discrete output Real readSuccess "Table read success";

external "C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1D.readTableData;

  */
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1D_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1D.readTableData")
  {
    /* Declare outputs and temporaries */
    double   readSuccess0_0;
    readSuccess0_0=0;
    /* Start of real code */
    {
      extern double (ModelicaStandardTables_CombiTable1D_read)(void*, int , int );
      readSuccess0_0 = (ModelicaStandardTables_CombiTable1D_read)(
        externalTable_[tableID0_0.id_0member].obj_, forceRead0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return readSuccess0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D;

  */
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
        const char* , double  const *, size_t, size_t, int  const *, size_t, int );
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Types.ExternalCombiTable1D.destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="C:/Program Files (x86)/Dymola 2015/Modelica/Library/Modelica 3.2.1/Resources/Library");
end Modelica.Blocks.Types.ExternalCombiTable1D.destructor;

  */
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
else
y := (y1+y2)/2;
end if;
annotation(smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2
discrete input Real x "abscissa value";
discrete input Real x_small(start = 0.01, min = 0.0) "approximation of function for |x| <= x_small";
discrete input Real k1(start = 1, min = 0.0) "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
discrete input Real k2(start = 1, min = 0.0) "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y "ordinate value";

algorithm 
y := smooth(2, (if x >= x_small then sqrt(k1*x) else (if x <=  -x_small then  -sqrt(k2*abs(x)) else (if k1 >= k2 then Modelica.Fluid.Utilities.regRoot2.regRoot2_utility(x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regRoot2.regRoot2_utility( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regRoot2:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regRoot2;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2(double  x0_0, double  
  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regRoot2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN sqrtGuarded(k10_0*x0_0,"k1*x") ELSE IF 
        x0_0 <=  -xx_0small THEN  -sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)")
         ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -
        Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility( -x0_0, xx_0small, 
        k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2.regRoot2_utility
discrete input Real x;
discrete input Real x1 "approximation of function abs(x) < x1";
discrete input Real k1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|); k1 >= k2";
discrete input Real k2 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|))";
input Boolean use_yd0 "= true, if yd0 shall be used";
discrete input Real yd0(min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y;
protected 
discrete Real x2;
discrete Real xsqrt1;
discrete Real xsqrt2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real y0d;
discrete Real w1;
discrete Real w2;
discrete Real sqrt_k1(start = (if k1 > 0 then sqrt(k1) else 0));
discrete Real sqrt_k2(start = (if k2 > 0 then sqrt(k2) else 0));
public 
algorithm 
if (k2 > 0) then 
x2 :=  -x1*(k2/k1);
elseif (k1 > 0) then 
x2 :=  -x1;
else
y := 0;
return;
end if;
if (x <= x2) then 
y :=  -sqrt_k2*sqrt(abs(x));
else
y1 := sqrt_k1*sqrt(x1);
y2 :=  -sqrt_k2*sqrt(abs(x2));
y1d := sqrt_k1/sqrt(x1)/2;
y2d := sqrt_k2/sqrt(abs(x2))/2;
if (use_yd0) then 
y0d := yd0;
else
w := x2/x1;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
end if;
w1 := sqrt_k1*sqrt(8.75/x1);
w2 := sqrt_k2*sqrt(8.75/abs(x2));
y0d := smooth(2, min(y0d, 0.9*min(w1, w2)));
y := y1*(if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x/x1, 1, 1, y1d*x1/y1, y0d*x1/y1) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x/x1, x2/x1, y2/y1, y2d*x1/y1, y0d*x1/y1));
end if;
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regRoot2.regRoot2_utility;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regRoot2.regRoot2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   xsqrt10_0;
    double   xsqrt20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   y0d0_0;
    double   w10_0;
    double   w20_0;
    double   sqrtx_0k1;
    double   sqrtx_0k2;
    y0_0=0;
    x20_0=0;
    xsqrt10_0=0;
    xsqrt20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    y0d0_0=0;
    w10_0=0;
    w20_0=0;
    sqrtx_0k1 = IF k10_0 > 0 THEN sqrtGuarded(k10_0,"k1") ELSE 0;
    sqrtx_0k2 = IF k20_0 > 0 THEN sqrtGuarded(k20_0,"k2") ELSE 0;
    /* Start of real code */
      if (k20_0 > 0) {
        x20_0 =  -x10_0*divmacro(k20_0,"k2",k10_0,"k1");
      }
      else if (k10_0 > 0) {
        x20_0 =  -x10_0;
      }
      else{
        y0_0 = 0;
        goto returnTag;
      }
      if (x0_0 <= x20_0) {
        y0_0 =  -sqrtx_0k2*sqrtGuarded(fabs(x0_0),"abs(x)");
      }
      else{
        y10_0 = sqrtx_0k1*sqrtGuarded(x10_0,"x1");
        y20_0 =  -sqrtx_0k2*sqrtGuarded(fabs(x20_0),"abs(x2)");
        y1d0_0 = divmacro(sqrtx_0k1,"sqrt_k1",sqrtGuarded(x10_0,"x1"),"sqrt(x1)")
          /(double)(2);
        y2d0_0 = divmacro(sqrtx_0k2,"sqrt_k2",sqrtGuarded(fabs(x20_0),"abs(x2)"),
          "sqrt(abs(x2))")/(double)(2);
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = sqrtx_0k1*sqrtGuarded(divmacro(8.75,"8.75",x10_0,"x1"),"8.75/x1");
        w20_0 = sqrtx_0k2*sqrtGuarded(divmacro(8.75,"8.75",fabs(x20_0),"abs(x2)"),
          "8.75/abs(x2)");
        y0d0_0 = RealBmin(y0d0_0, 0.9*RealBmin(w10_0, w20_0));
        y0_0 = y10_0*(IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1")) ELSE 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero(divmacro(
          x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), divmacro(y20_0,
          "y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,"y1"), divmacro
          (y0d0_0*x10_0,"y0d*x1",y10_0,"y1")));
      }
    returnTag:
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2:der
discrete input Real x;
discrete input Real x_small(start = 0.01);
discrete input Real k1(start = 1);
discrete input Real k2(start = 1);
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
public 
discrete input Real x_der;
discrete input Real x_small_der(start = 0.0);
discrete input Real k1_der(start = 0);
discrete input Real k2_der(start = 0);
discrete input Real yd0_der(start = 0);
discrete output Real y_der;

algorithm 
y_der := smooth(1, (if x >= x_small then 0.5*(k1_der*x+k1*x_der)/sqrt(k1*x) else (if x <=  -x_small then  -0.5*(k2_der*abs(x)+k2*(x_der*noEvent((if x > 0 then 1 else -1))))/sqrt(k2*abs(x)) else (if k1 >= k2 then Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der(x, x_small, k1, k2, use_yd0, yd0, x_der, x_small_der, k1_der, k2_der, yd0_der) else  -Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der( -x, x_small, k2, k1, use_yd0, yd0,  -x_der, x_small_der, k2_der, k1_der, yd0_der)))));
annotation(derivative(order=2, zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regRoot2:der:der, smoothOrder=1);
end Modelica.Fluid.Utilities.regRoot2:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regRoot2:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IF x0_0 >= xx_0small THEN divmacro(0.5*(k1x_0der*x0_0+k10_0*
        xx_0der),"0.5*(k1_der*x+k1*x_der)",sqrtGuarded(k10_0*x0_0,"k1*x"),
        "sqrt(k1*x)") ELSE IF x0_0 <=  -xx_0small THEN  -divmacro(0.5*(k2x_0der*
        fabs(x0_0)+k20_0*xx_0der*(IF x0_0 > 0 THEN 1 ELSE -1)),"0.5*(k2_der*abs(x)+k2*(x_der*noEvent((if x > 0 then 1 else -1))))",
        sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)"),"sqrt(k2*abs(x))") ELSE IF 
        k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0, xx_0der, 
        xx_0smallx_0der, k1x_0der, k2x_0der, yd0x_0der) ELSE  -Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0,  -xx_0der, 
        xx_0smallx_0der, k2x_0der, k1x_0der, yd0x_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2
discrete input Real x "abscissa value";
discrete input Real x_small(start = 0.01, min = 0.0) "approximation of function for |x| <= x_small";
discrete input Real k1(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
discrete input Real k2(start = 1, min = 0.0) "y = (if x>=0 then k1 else k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y "ordinate value";

algorithm 
y := smooth(2, (if x >= x_small then k1*x^2 else (if x <=  -x_small then  -k2*x^2 else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility(x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN k10_0*sqr(x0_0) ELSE IF x0_0 <=  -
        xx_0small THEN  -k20_0*sqr(x0_0) ELSE IF k10_0 >= k20_0 THEN 
        Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(x0_0, xx_0small,
         k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
discrete input Real x;
discrete input Real x1 "approximation of function abs(x) < x1";
discrete input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
discrete input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
input Boolean use_yd0(start = false) "= true, if yd0 shall be used";
discrete input Real yd0(start = 1, min = 0.0) "Desired derivative at x=0: dy/dx = yd0";
discrete output Real y;
protected 
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
algorithm 
x2 :=  -x1;
if (x <= x2) then 
y :=  -k2*x^2;
else
y1 := k1*x1^2;
y2 :=  -k2*x2^2;
y1d := k1*2*x1;
y2d :=  -k2*2*x2;
if (use_yd0) then 
y0d := yd0;
else
w := x2/x1;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
end if;
w1 := 2.23606797749979*k1*x1;
w2 := 2.23606797749979*k2*abs(x2);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d := ww;
end if;
y := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x1, y1, y1d, y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x, x2, y2, y2d, y0d));
end if;
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der, smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    /* Start of real code */
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        y0_0 =  -k20_0*sqr(x0_0);
      }
      else{
        y10_0 = k10_0*sqr(x10_0);
        y20_0 =  -k20_0*sqr(x20_0);
        y1d0_0 = k10_0*2*x10_0;
        y2d0_0 =  -k20_0*2*x20_0;
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0d0_0 = ww0_0;
        }
        y0_0 = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2:der
discrete input Real x;
discrete input Real x_small(start = 0.01);
discrete input Real k1(start = 1);
discrete input Real k2(start = 1);
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
public 
discrete input Real x_der;
discrete input Real x_small_der(start = 0.0);
discrete input Real k1_der(start = 0);
discrete input Real k2_der(start = 0);
discrete input Real yd0_der(start = 0);
discrete output Real y_der;

algorithm 
y_der := smooth(1, (if x >= x_small then k1_der*x^2+2.0*(k1*(x*x_der)) else (if x <=  -x_small then  -(k2_der*x^2+2.0*(k2*(x*x_der))) else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der(x, x_small, k1, k2, use_yd0, yd0, x_der, x_small_der, k1_der, k2_der, yd0_der) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der( -x, x_small, k2, k1, use_yd0, yd0,  -x_der, x_small_der, k2_der, k1_der, yd0_der)))));
annotation(derivative(order=2, zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2:der:der, smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IF x0_0 >= xx_0small THEN k1x_0der*sqr(x0_0)+2.0*k10_0*x0_0*
        xx_0der ELSE IF x0_0 <=  -xx_0small THEN  -(k2x_0der*sqr(x0_0)+2.0*k20_0
        *x0_0*xx_0der) ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0, xx_0der, 
        xx_0smallx_0der, k1x_0der, k2x_0der, yd0x_0der) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0,  -xx_0der, 
        xx_0smallx_0der, k2x_0der, k1x_0der, yd0x_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(RealSize( den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = RealSize( den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(1,"1",RealElement( den10_0, (SizeType)(i0_0_0)),
            "den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = RealSize( den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealElement(divmacro(RealElement( den20_0, (SizeType)(i0_0_0), 
            (SizeType)(2)),"den2[i, 2]",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(i0_0_0));
          SetRealElement(divmacro(1,"1",RealElement( den20_0, (SizeType)(i0_0_0),
             (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
constant Real pi = 3.141592653589793;
discrete Real w_cut(start = 2.0*(pi*f_cut), unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(RealSize( c1x_0in,1)==RealSize( c0x_0in, 1),"size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   pi0_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, RealSize( crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, RealSize( c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    pi0_0 = 3.141592653589793;
    wx_0cut = 2.0*pi0_0*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
discrete input Real x "Value for which polynomial shall be evaluated";
discrete input Real x1 "Abscissa value";
discrete input Real y1 "y1=f(x1)";
discrete input Real y1d "First derivative at y1";
discrete input Real y0d "First derivative at f(x=0)";
discrete output Real y;
protected 
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
algorithm 
a1 := x1*y0d;
a2 := 3*y1-x1*y1d-2*a1;
a3 := y1-a2-a1;
xx := x/x1;
y := xx*(a1+xx*(a2+xx*a3));
annotation(derivative=Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der, smoothOrder=3);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    /* Start of real code */
      a10_0 = x10_0*y0d0_0;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a30_0 = y10_0-a20_0-a10_0;
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      y0_0 = xx0_0*(a10_0+xx0_0*(a20_0+xx0_0*a30_0));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der
discrete input Real x;
discrete input Real x1;
discrete input Real k1;
discrete input Real k2;
input Boolean use_yd0;
discrete input Real yd0;
protected 
discrete Real y;
discrete Real x2;
discrete Real xsqrt1;
discrete Real xsqrt2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real y0d;
discrete Real w1;
discrete Real w2;
discrete Real sqrt_k1(start = (if k1 > 0 then sqrt(k1) else 0));
discrete Real sqrt_k2(start = (if k2 > 0 then sqrt(k2) else 0));
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real k1_der;
discrete input Real k2_der;
discrete input Real yd0_der;
discrete output Real y_der;
protected 
discrete Real x2_der;
discrete Real xsqrt1_der;
discrete Real xsqrt2_der;
discrete Real y1_der;
discrete Real y2_der;
discrete Real y1d_der;
discrete Real y2d_der;
discrete Real w_der;
discrete Real y0d_der;
discrete Real w1_der;
discrete Real w2_der;
discrete Real sqrt_k1_der(start = (if k1 > 0 then 0.5*k1_der/sqrt(k1) else 0));
discrete Real sqrt_k2_der(start = (if k2 > 0 then 0.5*k2_der/sqrt(k2) else 0));
public 
algorithm 
if (k2 > 0) then 
x2_der := x1*k2*k1_der/k1^2-(x1_der*k2+x1*k2_der)/k1;
x2 :=  -x1*k2/k1;
elseif (k1 > 0) then 
x2_der :=  -x1_der;
x2 :=  -x1;
else
y_der := 0;
y := 0;
return;
end if;
if (x <= x2) then 
y_der :=  -(sqrt_k2_der*sqrt(abs(x))+0.5*(sqrt_k2*(x_der*noEvent((if x > 0 then 1 else -1))))/sqrt(abs(x)));
else
y1_der := sqrt_k1_der*sqrt(x1)+0.5*(sqrt_k1*x1_der)/sqrt(x1);
y1 := sqrt_k1*sqrt(x1);
y2_der :=  -(sqrt_k2_der*sqrt(abs(x2))+0.5*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))/sqrt(abs(x2)));
y2 :=  -sqrt_k2*sqrt(abs(x2));
y1d_der := 0.5*sqrt_k1_der/sqrt(x1)-0.25*(sqrt_k1*x1_der)/sqrt(x1)/sqrt(x1)^2;
y1d := 0.5*sqrt_k1/sqrt(x1);
y2d_der := 0.5*sqrt_k2_der/sqrt(abs(x2))-0.25*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))/sqrt(abs(x2))/sqrt(abs(x2))^2;
y2d := 0.5*sqrt_k2/sqrt(abs(x2));
if (use_yd0) then 
y0d_der := yd0_der;
y0d := yd0;
else
w_der := x2_der/x1-x2*x1_der/x1^2;
w := x2/x1;
y0d_der := ((3*y2_der-(x2_der*y2d+x2*y2d_der))/w-(3*y2-x2*y2d)*w_der/w^2-((3*y1_der-(x1_der*y1d+x1*y1d_der))*w+(3*y1-x1*y1d)*w_der))/(2.0*(x1*(1-w)))-2.0*(((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)*(x1_der*(1-w)-x1*w_der))/(2.0*(x1*(1-w)))^2;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2.0*(x1*(1-w)));
end if;
w1_der := sqrt_k1_der*sqrt(8.75/x1)-4.375*(sqrt_k1*x1_der)/x1^2/sqrt(8.75/x1);
w1 := sqrt_k1*sqrt(8.75/x1);
w2_der := sqrt_k2_der*sqrt(8.75/abs(x2))-4.375*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))/abs(x2)^2/sqrt(8.75/abs(x2));
w2 := sqrt_k2*sqrt(8.75/abs(x2));
y0d_der := smooth(1, (if noEvent(y0d < 0.9*min(w1, w2)) then y0d_der else 0.9*(if noEvent(w1 < w2) then w1_der else w2_der)));
y0d := smooth(2, min(y0d, 0.9*min(w1, w2)));
y_der := y1_der*(if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x/x1, 1, 1, y1d*x1/y1, y0d*x1/y1) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero(x/x1, x2/x1, y2/y1, y2d*x1/y1, y0d*x1/y1))+y1*(if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x/x1, 1, 1, y1d*x1/y1, y0d*x1/y1, x_der/x1-x*x1_der/x1^2, 0, 0, (y1d_der*x1+y1d*x1_der)/y1-y1d*x1*y1_der/y1^2, (y0d_der*x1+y0d*x1_der)/y1-y0d*x1*y1_der/y1^2) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x/x1, x2/x1, y2/y1, y2d*x1/y1, y0d*x1/y1, x_der/x1-x*x1_der/x1^2, x2_der/x1-x2*x1_der/x1^2, y2_der/y1-y2*y1_der/y1^2, (y2d_der*x1+y2d*x1_der)/y1-y2d*x1*y1_der/y1^2, (y0d_der*x1+y0d*x1_der)/y1-y0d*x1*y1_der/y1^2));
end if;
annotation(derivative(order=2, zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der:der, smoothOrder=1);
end Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   xsqrt10_0;
    double   xsqrt20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   y0d0_0;
    double   w10_0;
    double   w20_0;
    double   sqrtx_0k1;
    double   sqrtx_0k2;
    double   yx_0der;
    double   x2x_0der;
    double   xsqrt1x_0der;
    double   xsqrt2x_0der;
    double   y1x_0der;
    double   y2x_0der;
    double   y1dx_0der;
    double   y2dx_0der;
    double   wx_0der;
    double   y0dx_0der;
    double   w1x_0der;
    double   w2x_0der;
    double   sqrtx_0k1x_0der;
    double   sqrtx_0k2x_0der;
    y0_0=0;
    x20_0=0;
    xsqrt10_0=0;
    xsqrt20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    y0d0_0=0;
    w10_0=0;
    w20_0=0;
    sqrtx_0k1 = IF k10_0 > 0 THEN sqrtGuarded(k10_0,"k1") ELSE 0;
    sqrtx_0k2 = IF k20_0 > 0 THEN sqrtGuarded(k20_0,"k2") ELSE 0;
    yx_0der=0;
    x2x_0der=0;
    xsqrt1x_0der=0;
    xsqrt2x_0der=0;
    y1x_0der=0;
    y2x_0der=0;
    y1dx_0der=0;
    y2dx_0der=0;
    wx_0der=0;
    y0dx_0der=0;
    w1x_0der=0;
    w2x_0der=0;
    sqrtx_0k1x_0der = IF k10_0 > 0 THEN divmacro(0.5*k1x_0der,"0.5*k1_der",
      sqrtGuarded(k10_0,"k1"),"sqrt(k1)") ELSE 0;
    sqrtx_0k2x_0der = IF k20_0 > 0 THEN divmacro(0.5*k2x_0der,"0.5*k2_der",
      sqrtGuarded(k20_0,"k2"),"sqrt(k2)") ELSE 0;
    /* Start of real code */
      if (k20_0 > 0) {
        x2x_0der = divmacro(x10_0*k20_0*k1x_0der,"x1*k2*k1_der",sqr(k10_0),
          "k1^2")-divmacro(x1x_0der*k20_0+x10_0*k2x_0der,"x1_der*k2+x1*k2_der",
          k10_0,"k1");
        x20_0 =  -divmacro(x10_0*k20_0,"x1*k2",k10_0,"k1");
      }
      else if (k10_0 > 0) {
        x2x_0der =  -x1x_0der;
        x20_0 =  -x10_0;
      }
      else{
        yx_0der = 0;
        y0_0 = 0;
        goto returnTag;
      }
      if (x0_0 <= x20_0) {
        yx_0der =  -(sqrtx_0k2x_0der*sqrtGuarded(fabs(x0_0),"abs(x)")+divmacro(
          0.5*sqrtx_0k2*xx_0der*(IF x0_0 > 0 THEN 1 ELSE -1),"0.5*(sqrt_k2*(x_der*noEvent((if x > 0 then 1 else -1))))",
          sqrtGuarded(fabs(x0_0),"abs(x)"),"sqrt(abs(x))"));
      }
      else{
        y1x_0der = sqrtx_0k1x_0der*sqrtGuarded(x10_0,"x1")+divmacro(0.5*
          sqrtx_0k1*x1x_0der,"0.5*(sqrt_k1*x1_der)",sqrtGuarded(x10_0,"x1"),
          "sqrt(x1)");
        y10_0 = sqrtx_0k1*sqrtGuarded(x10_0,"x1");
        y2x_0der =  -(sqrtx_0k2x_0der*sqrtGuarded(fabs(x20_0),"abs(x2)")+
          divmacro(0.5*sqrtx_0k2*x2x_0der*(IF x20_0 > 0 THEN 1 ELSE -1),
          "0.5*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))",
          sqrtGuarded(fabs(x20_0),"abs(x2)"),"sqrt(abs(x2))"));
        y20_0 =  -sqrtx_0k2*sqrtGuarded(fabs(x20_0),"abs(x2)");
        y1dx_0der = divmacro(0.5*sqrtx_0k1x_0der,"0.5*sqrt_k1_der",sqrtGuarded(
          x10_0,"x1"),"sqrt(x1)")-divmacro(divmacro(0.25*sqrtx_0k1*x1x_0der,
          "0.25*(sqrt_k1*x1_der)",sqrtGuarded(x10_0,"x1"),"sqrt(x1)"),
          "0.25*(sqrt_k1*x1_der)/sqrt(x1)",sqr(sqrtGuarded(x10_0,"x1")),
          "sqrt(x1)^2");
        y1d0_0 = divmacro(0.5*sqrtx_0k1,"0.5*sqrt_k1",sqrtGuarded(x10_0,"x1"),
          "sqrt(x1)");
        y2dx_0der = divmacro(0.5*sqrtx_0k2x_0der,"0.5*sqrt_k2_der",sqrtGuarded(
          fabs(x20_0),"abs(x2)"),"sqrt(abs(x2))")-divmacro(divmacro(0.25*
          sqrtx_0k2*x2x_0der*(IF x20_0 > 0 THEN 1 ELSE -1),"0.25*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))",
          sqrtGuarded(fabs(x20_0),"abs(x2)"),"sqrt(abs(x2))"),"0.25*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))/sqrt(abs(x2))",
          sqr(sqrtGuarded(fabs(x20_0),"abs(x2)")),"sqrt(abs(x2))^2");
        y2d0_0 = divmacro(0.5*sqrtx_0k2,"0.5*sqrt_k2",sqrtGuarded(fabs(x20_0),
          "abs(x2)"),"sqrt(abs(x2))");
        if (usex_0yd0) {
          y0dx_0der = yd0x_0der;
          y0d0_0 = yd00_0;
        }
        else{
          wx_0der = divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
            x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2");
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          /* Introducing 17 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 17 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvar[17];
          helpvar[0] = 3*y2x_0der-(x2x_0der*y2d0_0+x20_0*y2dx_0der);
          helpvar[1] = divmacro(1.0,"1.0",w0_0,"w");
          helpvar[2] = 3*y20_0-x20_0*y2d0_0;
          helpvar[3] = helpvar[2]*wx_0der;
          helpvar[4] = sqr(w0_0);
          helpvar[5] = divmacro(1.0,"1.0",helpvar[4],"w^2");
          helpvar[6] = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der);
          helpvar[7] = 3*y10_0-x10_0*y1d0_0;
          helpvar[8] = 1-w0_0;
          helpvar[9] = 2.0*x10_0*helpvar[8];
          helpvar[10] = divmacro(1.0,"1.0",helpvar[9],"2.0*(x1*(1-w))");
          helpvar[11] = helpvar[1]*helpvar[2];
          helpvar[12] = helpvar[7]*w0_0;
          helpvar[13] = x1x_0der*helpvar[8];
          helpvar[14] = x10_0*wx_0der;
          helpvar[15] = sqr(helpvar[9]);
          helpvar[16] = divmacro(1.0,"1.0",helpvar[15],"(2.0*(x1*(1-w)))^2");
          y0dx_0der = helpvar[10]*(helpvar[1]*helpvar[0]-helpvar[5]*helpvar[3]-(
            helpvar[6]*w0_0+helpvar[7]*wx_0der))-helpvar[16]*2.0*(helpvar[11]-
            helpvar[12])*(helpvar[13]-helpvar[14]);
          }
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2.0*
            x10_0*(1-w0_0),"2.0*(x1*(1-w))");
        }
        w1x_0der = sqrtx_0k1x_0der*sqrtGuarded(divmacro(8.75,"8.75",x10_0,"x1"),
          "8.75/x1")-divmacro(divmacro(4.375*sqrtx_0k1*x1x_0der,"4.375*(sqrt_k1*x1_der)",
          sqr(x10_0),"x1^2"),"4.375*(sqrt_k1*x1_der)/x1^2",sqrtGuarded(divmacro(
          8.75,"8.75",x10_0,"x1"),"8.75/x1"),"sqrt(8.75/x1)");
        w10_0 = sqrtx_0k1*sqrtGuarded(divmacro(8.75,"8.75",x10_0,"x1"),"8.75/x1");
        w2x_0der = sqrtx_0k2x_0der*sqrtGuarded(divmacro(8.75,"8.75",fabs(x20_0),
          "abs(x2)"),"8.75/abs(x2)")-divmacro(divmacro(4.375*sqrtx_0k2*x2x_0der*
          (IF x20_0 > 0 THEN 1 ELSE -1),"4.375*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))",
          sqr(fabs(x20_0)),"abs(x2)^2"),"4.375*(sqrt_k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))))/abs(x2)^2",
          sqrtGuarded(divmacro(8.75,"8.75",fabs(x20_0),"abs(x2)"),"8.75/abs(x2)"),
          "sqrt(8.75/abs(x2))");
        w20_0 = sqrtx_0k2*sqrtGuarded(divmacro(8.75,"8.75",fabs(x20_0),"abs(x2)"),
          "8.75/abs(x2)");
        y0dx_0der = IF y0d0_0 < 0.9*RealBmin(w10_0, w20_0) THEN y0dx_0der ELSE 
          0.9*(IF w10_0 < w20_0 THEN w1x_0der ELSE w2x_0der);
        y0d0_0 = RealBmin(y0d0_0, 0.9*RealBmin(w10_0, w20_0));
        yx_0der = y1x_0der*(IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1")) ELSE 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero(divmacro(
          x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), divmacro(y20_0,
          "y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,"y1"), divmacro
          (y0d0_0*x10_0,"y0d*x1",y10_0,"y1")))+y10_0*(IF x0_0 >= 0 THEN 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der(
          divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1"), divmacro(
          xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,"x*x1_der",sqr(
          x10_0),"x1^2"), 0, 0, divmacro(y1dx_0der*x10_0+y1d0_0*x1x_0der,
          "y1d_der*x1+y1d*x1_der",y10_0,"y1")-divmacro(y1d0_0*x10_0*y1x_0der,
          "y1d*x1*y1_der",sqr(y10_0),"y1^2"), divmacro(y0dx_0der*x10_0+y0d0_0*
          x1x_0der,"y0d_der*x1+y0d*x1_der",y10_0,"y1")-divmacro(y0d0_0*x10_0*
          y1x_0der,"y0d*x1*y1_der",sqr(y10_0),"y1^2")) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (divmacro(x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), 
          divmacro(y20_0,"y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,
          "y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1"), divmacro(xx_0der,
          "x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,"x*x1_der",sqr(x10_0),
          "x1^2"), divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
          x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2"), divmacro(y2x_0der,"y2_der",
          y10_0,"y1")-divmacro(y20_0*y1x_0der,"y2*y1_der",sqr(y10_0),"y1^2"), 
          divmacro(y2dx_0der*x10_0+y2d0_0*x1x_0der,"y2d_der*x1+y2d*x1_der",y10_0,
          "y1")-divmacro(y2d0_0*x10_0*y1x_0der,"y2d*x1*y1_der",sqr(y10_0),"y1^2"),
           divmacro(y0dx_0der*x10_0+y0d0_0*x1x_0der,"y0d_der*x1+y0d*x1_der",
          y10_0,"y1")-divmacro(y0d0_0*x10_0*y1x_0der,"y0d*x1*y1_der",sqr(y10_0),
          "y1^2")));
      }
    returnTag:
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der
discrete input Real x;
discrete input Real x1;
discrete input Real k1;
discrete input Real k2;
input Boolean use_yd0(start = false);
discrete input Real yd0(start = 1);
protected 
discrete Real y;
discrete Real x2;
discrete Real y1;
discrete Real y2;
discrete Real y1d;
discrete Real y2d;
discrete Real w;
discrete Real w1;
discrete Real w2;
discrete Real y0d;
discrete Real ww;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real k1_der;
discrete input Real k2_der;
discrete input Real yd0_der(start = 0);
discrete output Real y_der;
protected 
discrete Real x2_der;
discrete Real y1_der;
discrete Real y2_der;
discrete Real y1d_der;
discrete Real y2d_der;
discrete Real w_der;
discrete Real w1_der;
discrete Real w2_der;
discrete Real y0d_der;
discrete Real ww_der;
public 
algorithm 
x2_der :=  -x1_der;
x2 :=  -x1;
if (x <= x2) then 
y_der :=  -(k2_der*x^2+2.0*(k2*(x*x_der)));
else
y1_der := k1_der*x1^2+2.0*(k1*(x1*x1_der));
y1 := k1*x1^2;
y2_der :=  -(k2_der*x2^2+2.0*(k2*(x2*x2_der)));
y2 :=  -k2*x2^2;
y1d_der := 2.0*(k1_der*x1+k1*x1_der);
y1d := 2.0*(k1*x1);
y2d_der := (-2.0)*(k2_der*x2+k2*x2_der);
y2d := (-2.0)*(k2*x2);
if (use_yd0) then 
y0d_der := yd0_der;
y0d := yd0;
else
w_der := x2_der/x1-x2*x1_der/x1^2;
w := x2/x1;
y0d_der := ((3*y2_der-(x2_der*y2d+x2*y2d_der))/w-(3*y2-x2*y2d)*w_der/w^2-((3*y1_der-(x1_der*y1d+x1*y1d_der))*w+(3*y1-x1*y1d)*w_der))/(2.0*(x1*(1-w)))-2.0*(((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)*(x1_der*(1-w)-x1*w_der))/(2.0*(x1*(1-w)))^2;
y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2.0*(x1*(1-w)));
end if;
w1_der := 2.23606797749979*(k1_der*x1+k1*x1_der);
w1 := 2.23606797749979*(k1*x1);
w2_der := 2.23606797749979*(k2_der*abs(x2)+k2*(x2_der*noEvent((if x2 > 0 then 1 else -1))));
w2 := 2.23606797749979*(k2*abs(x2));
ww_der := 0.9*(if w1 < w2 then w1_der else w2_der);
ww := 0.9*(if w1 < w2 then w1 else w2);
if (ww < y0d) then 
y0d_der := ww_der;
y0d := ww;
end if;
y_der := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x1, y1, y1d, y0d, x_der, x1_der, y1_der, y1d_der, y0d_der) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x, x2, y2, y2d, y0d, x_der, x2_der, y2_der, y2d_der, y0d_der));
end if;
annotation(derivative(order=2, zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der:der, smoothOrder=1);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    double   ww0_0;
    double   yx_0der;
    double   x2x_0der;
    double   y1x_0der;
    double   y2x_0der;
    double   y1dx_0der;
    double   y2dx_0der;
    double   wx_0der;
    double   w1x_0der;
    double   w2x_0der;
    double   y0dx_0der;
    double   wwx_0der;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    ww0_0=0;
    yx_0der=0;
    x2x_0der=0;
    y1x_0der=0;
    y2x_0der=0;
    y1dx_0der=0;
    y2dx_0der=0;
    wx_0der=0;
    w1x_0der=0;
    w2x_0der=0;
    y0dx_0der=0;
    wwx_0der=0;
    /* Start of real code */
      x2x_0der =  -x1x_0der;
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        yx_0der =  -(k2x_0der*sqr(x0_0)+2.0*k20_0*x0_0*xx_0der);
      }
      else{
        y1x_0der = k1x_0der*sqr(x10_0)+2.0*k10_0*x10_0*x1x_0der;
        y10_0 = k10_0*sqr(x10_0);
        y2x_0der =  -(k2x_0der*sqr(x20_0)+2.0*k20_0*x20_0*x2x_0der);
        y20_0 =  -k20_0*sqr(x20_0);
        y1dx_0der = 2.0*(k1x_0der*x10_0+k10_0*x1x_0der);
        y1d0_0 = 2.0*k10_0*x10_0;
        y2dx_0der = (-2.0)*(k2x_0der*x20_0+k20_0*x2x_0der);
        y2d0_0 = (-2.0)*k20_0*x20_0;
        if (usex_0yd0) {
          y0dx_0der = yd0x_0der;
          y0d0_0 = yd00_0;
        }
        else{
          wx_0der = divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
            x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2");
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          /* Introducing 17 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 17 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvar[17];
          helpvar[0] = 3*y2x_0der-(x2x_0der*y2d0_0+x20_0*y2dx_0der);
          helpvar[1] = divmacro(1.0,"1.0",w0_0,"w");
          helpvar[2] = 3*y20_0-x20_0*y2d0_0;
          helpvar[3] = helpvar[2]*wx_0der;
          helpvar[4] = sqr(w0_0);
          helpvar[5] = divmacro(1.0,"1.0",helpvar[4],"w^2");
          helpvar[6] = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der);
          helpvar[7] = 3*y10_0-x10_0*y1d0_0;
          helpvar[8] = 1-w0_0;
          helpvar[9] = 2.0*x10_0*helpvar[8];
          helpvar[10] = divmacro(1.0,"1.0",helpvar[9],"2.0*(x1*(1-w))");
          helpvar[11] = helpvar[1]*helpvar[2];
          helpvar[12] = helpvar[7]*w0_0;
          helpvar[13] = x1x_0der*helpvar[8];
          helpvar[14] = x10_0*wx_0der;
          helpvar[15] = sqr(helpvar[9]);
          helpvar[16] = divmacro(1.0,"1.0",helpvar[15],"(2.0*(x1*(1-w)))^2");
          y0dx_0der = helpvar[10]*(helpvar[1]*helpvar[0]-helpvar[5]*helpvar[3]-(
            helpvar[6]*w0_0+helpvar[7]*wx_0der))-helpvar[16]*2.0*(helpvar[11]-
            helpvar[12])*(helpvar[13]-helpvar[14]);
          }
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2.0*
            x10_0*(1-w0_0),"2.0*(x1*(1-w))");
        }
        w1x_0der = 2.23606797749979*(k1x_0der*x10_0+k10_0*x1x_0der);
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w2x_0der = 2.23606797749979*(k2x_0der*fabs(x20_0)+k20_0*x2x_0der*(IF 
          x20_0 > 0 THEN 1 ELSE -1));
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        wwx_0der = 0.9*(IF w10_0 < w20_0 THEN w1x_0der ELSE w2x_0der);
        ww0_0 = 0.9*(IF w10_0 < w20_0 THEN w10_0 ELSE w20_0);
        if (ww0_0 < y0d0_0) {
          y0dx_0der = wwx_0der;
          y0d0_0 = ww0_0;
        }
        yx_0der = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0, xx_0der, x1x_0der, y1x_0der, 
          y1dx_0der, y0dx_0der) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0, xx_0der, x2x_0der, y2x_0der, 
          y2dx_0der, y0dx_0der);
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der
discrete input Real x;
discrete input Real x1;
discrete input Real y1;
discrete input Real y1d;
discrete input Real y0d;
protected 
discrete Real y;
discrete Real a1;
discrete Real a2;
discrete Real a3;
discrete Real xx;
public 
discrete input Real x_der;
discrete input Real x1_der;
discrete input Real y1_der;
discrete input Real y1d_der;
discrete input Real y0d_der;
discrete output Real y_der;
protected 
discrete Real a1_der;
discrete Real a2_der;
discrete Real a3_der;
discrete Real xx_der;
public 
algorithm 
a1_der := x1_der*y0d+x1*y0d_der;
a1 := x1*y0d;
a2_der := 3*y1_der-(x1_der*y1d+x1*y1d_der)-2*a1_der;
a2 := 3*y1-x1*y1d-2*a1;
a3_der := y1_der-a2_der-a1_der;
a3 := y1-a2-a1;
xx_der := x_der/x1-x*x1_der/x1^2;
xx := x/x1;
y_der := xx_der*(a1+xx*(a2+xx*a3))+xx*(a1_der+xx_der*(a2+xx*a3)+xx*(a2_der+xx_der*a3+xx*a3_der));
annotation(derivative(order=2)=Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der:der, smoothOrder=2);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    double   yx_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   a3x_0der;
    double   xxx_0der;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    yx_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    a3x_0der=0;
    xxx_0der=0;
    /* Start of real code */
      a1x_0der = x1x_0der*y0d0_0+x10_0*y0dx_0der;
      a10_0 = x10_0*y0d0_0;
      a2x_0der = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der)-2*a1x_0der;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a3x_0der = y1x_0der-a2x_0der-a1x_0der;
      a30_0 = y10_0-a20_0-a10_0;
      xxx_0der = divmacro(xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,
        "x*x1_der",sqr(x10_0),"x1^2");
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      yx_0der = xxx_0der*(a10_0+xx0_0*(a20_0+xx0_0*a30_0))+xx0_0*(a1x_0der+
        xxx_0der*(a20_0+xx0_0*a30_0)+xx0_0*(a2x_0der+xxx_0der*a30_0+xx0_0*
        a3x_0der));
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
BreakSectionFunctionDef(5)
BreakSectionFunctionDef(6)
BreakSectionFunctionDef(8)
BreakSectionFunctionDef(9)
BreakSectionFunctionDef(11)
BreakSectionFunctionDef(12)
BreakSectionFunctionDef(13)
BreakSectionFunctionDef(14)
BreakSectionFunctionDef(15)
BreakSectionFunctionDef(16)
BreakSectionFunctionDef(17)
BreakSectionFunctionDef(18)
BreakSectionFunctionDef(19)
#include <moutil.c>
PreNonAliasDef(0)
PreNonAliasDef(1)
DYMOLA_STATIC const char*modelName="Annex60.Experimental.Benchmarks.CentralHeatingSystem.System1";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/christo/appdata/roaming/dynasim/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC long QJacobianCG_[16]={7 , 2 , 1 , 4 , 1 , 2 , 1 , 3 , 1 , 5 , 1
   , 6 , 1 , 7 , 1 , 8};
DYMOLA_STATIC long QJacobianGC_[57]={
1 , 1 , 1 , 4 , 4 , 1 , 1 , 1 , 0 , 0 , 2 , 0 , 0 , 2 , 2 , 0 , 0 , 0 , 3 , 0 , 0
   , 3 , 3 , 0 , 0 , 5 , 5 , 0 , 5 , 5 , 5 , 5 , 0 , 0 , 6 , 0 , 0 , 6 , 6 , 6
   , 7 , 0 , 7 , 0 , 0 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 8 , 8 , 8 , 0};
DYMOLA_STATIC double QJacobianCD_[9]={0  , 44 , 50 , 54 , 77 , 64 , 63 , 60 , 55};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = true;
W_[10] = 0.01;
W_[27] = true;
W_[33] = 0.01;
W_[35] = false;
W_[38] = 8000.0;
W_[43] = 0.01;
W_[44] = 8000.0;
W_[51] = true;
W_[57] = 0.01;
W_[59] = false;
W_[63] = 10.0;
W_[68] = 1;
W_[69] = 1;
W_[70] = 1;
W_[71] = 1;
W_[72] = 1;
W_[73] = 1;
W_[78] = 2;
W_[82] = true;
W_[86] = 1;
W_[91] = false;
W_[92] = true;
W_[94] = 0.01;
W_[96] = false;
W_[99] = 10.0;
W_[104] = 0.01;
W_[105] = 10.0;
W_[121] = true;
W_[125] = true;
W_[129] = 2;
W_[134] = 1;
W_[144] = 2;
W_[145] = 2;
W_[146] = 2;
W_[147] = 2;
W_[152] = 2;
W_[156] = false;
W_[164] = false;
W_[181] = 1;
W_[183] = 1;
W_[187] = true;
W_[190] = 0.01;
W_[192] = false;
W_[196] = 2000.0;
W_[201] = 0.01;
W_[202] = 2000.0;
W_[209] = true;
W_[214] = 0.01;
W_[216] = false;
W_[220] = 2000.0;
W_[225] = 0.01;
W_[226] = 2000.0;
W_[233] = true;
W_[234] = 0.01;
W_[236] = false;
W_[245] = 0.01;
W_[247] = 2;
W_[252] = false;
W_[275] = 1;
W_[294] = 1;
W_[298] = 1;
W_[313] = false;
W_[314] = false;
W_[333] = 1;
W_[334] = 1;
W_[337] = true;
W_[341] = false;
W_[342] = 1;
W_[343] = 1;
W_[344] = 1;
W_[345] = 1;
W_[350] = 2;
W_[354] = true;
W_[362] = false;
W_[365] = true;
W_[366] = true;
W_[370] = true;
W_[376] = false;
W_[377] = true;
W_[381] = false;
W_[387] = false;
W_[390] = true;
W_[395] = 1;
W_[396] = 1;
W_[397] = 2;
W_[400] = 2;
W_[403] = 2;
W_[404] = 0;
W_[405] = 0;
W_[406] = 2;
W_[412] = 1;
W_[420] = 1;
W_[421] = 1;
W_[422] = 1;
W_[427] = 2;
DYNSetAuxString("Water", 4);
W_[449] = 2;
W_[450] = 2;
W_[451] = 2;
W_[456] = 2;
W_[479] = 1;
W_[480] = 1;
W_[481] = 1;
W_[486] = 2;
W_[64] = false;
W_[65] = 0.1;
W_[391] = 4;
W_[1] = 1;
W_[2] = 1;
W_[3] = 1;
W_[4] = 1;
W_[5] = 4;
W_[8] = false;
W_[19] = 2;
W_[20] = 2;
W_[21] = 2;
W_[22] = 2;
W_[26] = 995.586;
W_[34] = 1.0000000000000002E-006;
W_[37] = false;
W_[39] = true;
W_[40] = false;
W_[50] = true;
W_[45] = false;
W_[46] = 1;
W_[47] = 4000;
W_[48] = 0.3;
W_[41] = 0.003;
W_[49] = 0.00011180339887498948;
W_[56] = false;
W_[58] = 1.0000000000000002E-006;
W_[61] = true;
W_[62] = false;
W_[66] = 30;
W_[67] = true;
W_[77] = 0.01;
W_[79] = 1.0000000000000002E-006;
W_[80] = true;
W_[112] = 995.586;
W_[81] = 0.0003013300709330987;
W_[84] = 995.586;
W_[85] = 995.586;
W_[87] = 293.15;
W_[88] = 300000;
W_[95] = 1.0000000000000002E-006;
W_[98] = false;
W_[100] = true;
W_[101] = false;
W_[111] = true;
W_[106] = false;
W_[107] = 1;
W_[108] = 4000;
W_[109] = 0.1;
W_[102] = 0.001;
W_[110] = 0.0031622776601683794;
W_[123] = 0.01;
W_[124] = 1.0000000000000002E-006;
W_[130] = 2;
W_[131] = 2;
W_[132] = 2;
W_[133] = 1;
W_[138] = 0.005;
W_[139] = 0.0001;
W_[140] = true;
W_[150] = 1.0;
W_[151] = 0.01;
W_[153] = 1.0000000000000002E-006;
W_[154] = true;
W_[155] = 0.005;
W_[158] = 995.586;
W_[159] = 995.586;
W_[160] = 293.15;
W_[161] = 300000;
W_[165] = 4184;
W_[172] = 0.05;
W_[182] = -1;
W_[185] = -1;
W_[191] = 1.0000000000000002E-006;
W_[195] = false;
W_[197] = true;
W_[198] = false;
W_[208] = true;
W_[203] = false;
W_[204] = 1;
W_[205] = 4000;
W_[206] = 0.3;
W_[199] = 0.003;
W_[207] = 0.00022360679774997895;
W_[215] = 1.0000000000000002E-006;
W_[219] = false;
W_[221] = true;
W_[222] = false;
W_[232] = true;
W_[227] = false;
W_[228] = 1;
W_[229] = 4000;
W_[230] = 0.3;
W_[223] = 0.003;
W_[231] = 0.00022360679774997895;
W_[235] = 1.0000000000000002E-006;
W_[239] = true;
W_[241] = true;
W_[242] = false;
W_[276] = false;
DYNSetAuxString("NoName", 0);
DYNSetAuxString("NoName", 1);
W_[289] = 2;
W_[290] = 2;
W_[295] = 5;
W_[296] = true;
W_[297] = false;
W_[311] = false;
W_[312] = true;
W_[316] = false;
W_[317] = true;
W_[318] = 995.586;
W_[335] = 1;
W_[336] = 1;
W_[338] = false;
W_[339] = 0.01;
W_[340] = 1.0000000000000002E-006;
W_[349] = 0.01;
W_[351] = 1.0000000000000002E-006;
W_[352] = true;
W_[356] = 995.586;
W_[357] = 995.586;
W_[358] = 293.15;
W_[359] = 300000;
W_[371] = false;
W_[372] = false;
W_[375] = 1.0000000000000002E-006;
W_[389] = 300000;
W_[394] = -1;
W_[399] = 4;
DYNSetAuxString("tab", 2);
DYNSetAuxString("C:/Users/christo/VirtualBox/modelica-annex60-issue45_benchmarks/Annex60/Experimental/Benchmarks/CentralHeatingSystem/COP_try.prn",
   3);
W_[423] = 1;
W_[435] = true;
W_[436] = true;
W_[447] = 995.586;
W_[452] = 2;
W_[455] = 1.0;
W_[464] = true;
W_[465] = true;
W_[477] = 995.586;
W_[482] = 1;
W_[494] = true;
W_[495] = true;
W_[505] = 995.586;
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
W_[116] = 1E+060;
W_[117] = -1E+060;
W_[135] = 343.15;
W_[136] = 293.15;
W_[415] = true;
W_[416] = 1;
W_[474] = false;
W_[471] = 0.0;
W_[470] = 4.97793;
W_[501] = 0.0;
W_[442] = 0.0;
W_[441] = 0.3;
W_[315] = 0;
W_[126] = 0.0;
W_[382] = 0;
W_[431] = 1.0;
W_[460] = 1.0;
W_[490] = 1.0;
W_[501] = 0.0;
W_[501] = 0.0;
W_[444] = 0.0003013300709330987;
W_[434] = 0.018015268;
W_[433] = 8.314472;
W_[430] = 995.586;
W_[368] = 0.0;
W_[369] = 995.586;
W_[493] = 0.018015268;
W_[492] = 8.314472;
W_[489] = 995.586;
W_[141] = 0.0;
W_[143] = 0.0;
W_[186] = 0.0;
W_[473] = 0.005;
W_[463] = 0.018015268;
W_[462] = 8.314472;
W_[459] = 995.586;
BoundParameterSection
AssertModelica(DP_[40] > 343.15,"rad.T_a_nominal > 343.15", "In RadiatorEN442_2, T_a_nominal must be higher than T_b_nominal");
AssertModelica(DP_[39] > 0,"rad.Q_flow_nominal > 0", "In RadiatorEN442_2, nominal power must be bigger than zero if T_b_nominal > TAir_nominal");
AssertModelica(DP_[85] > -1E-060,"val.dpFixed_nominal > -1E-060", StringAdd(
  StringAdd("Require dpFixed_nominal >= 0. Received dpFixed_nominal = ",
  Real2String2(DP_[85], true, 0))," Pa."));
PopAllMarks();
AssertModelica(DP_[90] >= DP_[91],"thermostat.yMax >= thermostat.yMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[90], true, 0)),") < yMin (="),Real2String2(DP_[91], true, 0)),
  ")"));
PopAllMarks();
AssertModelica(DP_[127] > 0,"pump.filter.A_ripple > 0", "A_ripple > 0 required");
AssertModelica(DP_[132] >= -1E-015,"dpSet.k >= -1E-015", StringAdd(
  "dp_in cannot be negative. Obtained dp_in = ",Real2String2(DP_[132], true, 0)));
PopAllMarks();
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[11] = DP_[8];
W_[18] = divmacro(1.0,"1.0",0.06*DP_[7],"0.06*room.UAmb");
W_[17] = DP_[7]*W_[18];
W_[24] = DP_[11];
W_[25] = DP_[10];
W_[42] = 995.586*(IF DP_[18] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[18] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[18])-
  7.22111E-007*powmacro(DP_[18],"pip1.sta_default.T",3,"3")-0.312920238272193*
  DP_[18]));
W_[74] = DP_[22];
W_[75] = DP_[23];
W_[76] = DP_[24];
W_[89] = W_[75];
W_[90] = W_[74];
W_[103] = 995.586*(IF DP_[29] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[29] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[29])-
  7.22111E-007*powmacro(DP_[29],"hea.preDro.sta_default.T",3,"3")-
  0.312920238272193*DP_[29]));
W_[113] = DP_[23];
W_[114] = DP_[22];
W_[115] = 4184*(W_[113]-273.15);
W_[119] = W_[116];
W_[120] = W_[117];
W_[137] = W_[136];
W_[148] = DP_[36];
W_[149] = DP_[37];
W_[162] = W_[149];
W_[163] = W_[148];
W_[171] = IF W_[135] > W_[136] THEN 1 ELSE -1;
W_[200] = 995.586*(IF DP_[54] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[54] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[54])-
  7.22111E-007*powmacro(DP_[54],"pip2.sta_default.T",3,"3")-0.312920238272193*
  DP_[54]));
W_[224] = 995.586*(IF DP_[60] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[60] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[60])-
  7.22111E-007*powmacro(DP_[60],"pip3.sta_default.T",3,"3")-0.312920238272193*
  DP_[60]));
W_[243] = 0.01*DP_[80];
W_[244] = 995.586*(IF DP_[77] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[77] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[77])-
  7.22111E-007*powmacro(DP_[77],"val.sta_default.T",3,"3")-0.312920238272193*
  DP_[77]));
W_[269] = DP_[68];
W_[278] = RealBmax(W_[269], 1E-008);
W_[255] = W_[278];
W_[258] = IF DP_[85] > 1E-060 THEN divmacro(0.01,"0.01",sqrtGuarded(DP_[85],
  "val.dpFixed_nominal"),"sqrt(val.dpFixed_nominal)") ELSE 0;
W_[263] = DP_[62];
W_[264] = DP_[63];
W_[265] = DP_[64];
W_[266] = DP_[65];
W_[267] = DP_[66];
W_[268] = DP_[67];
W_[270] = DP_[69];
W_[271] = DP_[70];
W_[272] = DP_[71];
W_[273] = DP_[72];
W_[274] = DP_[73];
W_[277] = W_[263];
W_[279] = W_[264];
W_[280] = W_[270];
W_[281] = W_[265];
W_[282] = W_[271];
W_[283] = W_[266];
W_[284] = W_[272];
W_[285] = W_[267];
W_[286] = W_[273];
W_[287] = W_[268];
W_[288] = W_[274];
W_[301] = DP_[92];
W_[304] = DP_[87];
W_[309] = DP_[90];
W_[310] = DP_[91];
W_[346] = DP_[111];
W_[347] = DP_[112];
W_[348] = DP_[113];
W_[363] = DP_[117];
W_[364] = divmacro(W_[349]*W_[363],"pump.vol.m_flow_nominal*pump.vol.tau",
  W_[356],"pump.vol.rho_default");
W_[353] = W_[364];
W_[360] = W_[347];
W_[361] = W_[346];
W_[373] = DP_[124];
W_[374] = DP_[3];
W_[384] = DP_[112];
W_[385] = DP_[111];
W_[386] = 4184*(W_[384]-273.15);
W_[398] = divmacro(5,"5",6.283185307179586*DP_[123],"6.283185307179586*pump.riseTime");
W_[401] = DP_[124];
W_[402] = fabs(DP_[125]);
W_[424] = W_[74];
W_[425] = W_[75];
W_[426] = W_[76];
W_[448] = 4184*(W_[425]-273.15);
W_[453] = W_[148];
W_[454] = W_[149];
W_[478] = 4184*(W_[454]-273.15);
W_[483] = W_[346];
W_[484] = W_[347];
W_[485] = W_[348];
W_[506] = 4184*(W_[484]-273.15);
W_[411] =  -divmacro(DP_[132],"dpSet.k",W_[402],"pump.filter.u_nominal");
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", val.phiLooUp.table, val.phiLooUp.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &W_[277], 2, 6, 2), IntegerTemporaryDense( &W_[289], 1, 1),
     2, 0, 1));
  W_[291] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
W_[500] = 995.586*W_[353];
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"tab\", \"C:/Users/christo/VirtualBox/modelica-annex60-issue45_benchmarks/Annex60/Experimental/Benchmarks/CentralHeatingSystem/COP_try.prn\", climateData.table, climateData.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("tab", "C:/Users/christo/VirtualBox/modelica-annex60-issue45_benchmarks/Annex60/Experimental/Benchmarks/CentralHeatingSystem/COP_try.prn",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( &DP_[134],
     1, 1), 1, 1, 1));
  W_[417] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
W_[13] = 288.15;
W_[28] = 0;
W_[36] = 0;
W_[52] = 0;
W_[55] = 0;
W_[60] = 0;
W_[83] = 288.15;
W_[97] = 0;
W_[122] = 0;
W_[127] = 288.15;
W_[128] = 288.15;
W_[142] = 288.15;
W_[174] = 0;
W_[193] = 0;
W_[212] = 300000;
W_[217] = 0;
W_[237] = 0;
W_[326] = 0;
W_[367] = 288.15;
W_[379] = 288.15;
W_[380] = 288.15;
W_[388] = 1;
W_[428] = 300000;
W_[457] = 300000;
W_[487] = 300000;
F_[0] = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
W_[31] = W_[478];
W_[53] = W_[115];
W_[93] = W_[115];
W_[173] = DP_[37];
W_[188] = W_[386];
W_[210] = DP_[111];
W_[392] = W_[373];
W_[439] = 0.3*(4184*(W_[89]-273.15)-301.3300709330987);
W_[468] = 4.97793*(4184*(W_[162]-273.15)-301.3300709330987);
W_[498] = 995.586*W_[353]*(4184*(W_[360]-273.15)-301.3300709330987);
InitialStartSection
Aux_[2] = W_[115];
Aux_[2] = W_[115];
InitialStartSection2
X_[0] = DP_[9];
X_[5] = W_[425];
X_[6] = W_[454];
X_[7] = W_[484];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
F_[3] = 0.0;
W_[329] = 1.0044335697769957E-008;
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[9] = IF W_[8] THEN 1 ELSE 100.0*DP_[6];
W_[11] = DP_[8];
W_[18] = divmacro(1.0,"1.0",0.06*DP_[7],"0.06*room.UAmb");
W_[17] = DP_[7]*W_[18];
W_[24] = DP_[11];
W_[25] = DP_[10];
W_[42] = 995.586*(IF DP_[18] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[18] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[18])-
  7.22111E-007*powmacro(DP_[18],"pip1.sta_default.T",3,"3")-0.312920238272193*
  DP_[18]));
W_[74] = DP_[22];
W_[75] = DP_[23];
W_[76] = DP_[24];
W_[89] = W_[75];
W_[90] = W_[74];
W_[103] = 995.586*(IF DP_[29] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[29] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[29])-
  7.22111E-007*powmacro(DP_[29],"hea.preDro.sta_default.T",3,"3")-
  0.312920238272193*DP_[29]));
W_[113] = DP_[23];
W_[114] = DP_[22];
W_[115] = 4184*(W_[113]-273.15);
W_[119] = W_[116];
W_[120] = W_[117];
W_[137] = W_[136];
W_[148] = DP_[36];
W_[149] = DP_[37];
W_[162] = W_[149];
W_[163] = W_[148];
W_[171] = IF W_[135] > W_[136] THEN 1 ELSE -1;
W_[200] = 995.586*(IF DP_[54] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[54] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[54])-
  7.22111E-007*powmacro(DP_[54],"pip2.sta_default.T",3,"3")-0.312920238272193*
  DP_[54]));
W_[224] = 995.586*(IF DP_[60] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[60] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[60])-
  7.22111E-007*powmacro(DP_[60],"pip3.sta_default.T",3,"3")-0.312920238272193*
  DP_[60]));
W_[251] = 0.0;
W_[248] = 0.0;
W_[249] = 0.0;
W_[250] = 1E-060;
  {
    W_[251] = 8.78410461157883E-007*DP_[79]*DP_[81];
    W_[248] = divmacro(W_[251],"val.Kv_SI",1.2042949486827428E-005*DP_[81]*
      0.0631,"1.2042949486827428E-005*(val.rhoStd*0.0631)");
    W_[249] = divmacro(W_[251],"val.Kv_SI",sqrtGuarded(DP_[81],"val.rhoStd"),
      "sqrt(val.rhoStd)");
    W_[250] = sqr(divmacro(0.01,"0.01",W_[251],"val.Kv_SI"));
  }
W_[240] = W_[250]+DP_[85];
W_[243] = 0.01*DP_[80];
W_[244] = 995.586*(IF DP_[77] < 278.15 THEN 1.44011135763E-005-4.63023776563E-008
  *DP_[77] ELSE 1E-006*exp(40.4003044106506+0.00080910285895*sqr(DP_[77])-
  7.22111E-007*powmacro(DP_[77],"val.sta_default.T",3,"3")-0.312920238272193*
  DP_[77]));
W_[246] = fabs(W_[240]);
W_[269] = DP_[68];
W_[278] = RealBmax(W_[269], 1E-008);
W_[255] = W_[278];
W_[258] = IF DP_[85] > 1E-060 THEN divmacro(0.01,"0.01",sqrtGuarded(DP_[85],
  "val.dpFixed_nominal"),"sqrt(val.dpFixed_nominal)") ELSE 0;
W_[263] = DP_[62];
AssertModelica(Equal(W_[263], 0, 0),"val.flowCharacteristics.y[1] == 0", 
  "flowCharateristics.y[1] must be 0.");
W_[264] = DP_[63];
W_[265] = DP_[64];
W_[266] = DP_[65];
W_[267] = DP_[66];
W_[268] = DP_[67];
AssertModelica(Equal(W_[268], 1, 1),"val.flowCharacteristics.y[6] == 1", 
  "flowCharateristics.y[end] must be 1.");
AssertModelica((PushModelContext(1,"Annex60.Utilities.Math.Functions.isMonotonic(val.flowCharacteristics.y, true)")
  Annex60_Utilities_Math_Functions_isMonotonic(RealTemporaryDense( &W_[263], 1, 6),
   true)),"Annex60.Utilities.Math.Functions.isMonotonic(val.flowCharacteristics.y, true)",
   "The values for y in flowCharacteristics must be strictly monotone increasing.");
PopAllMarks();
W_[270] = DP_[69];
W_[271] = DP_[70];
W_[272] = DP_[71];
W_[273] = DP_[72];
W_[274] = DP_[73];
AssertModelica(Equal(W_[274], 1, 2),"val.flowCharacteristics.phi[6] == 1", 
  "flowCharateristics.phi[end] must be 1.");
AssertModelica((PushModelContext(1,"Annex60.Utilities.Math.Functions.isMonotonic(val.flowCharacteristics.phi, true)")
  Annex60_Utilities_Math_Functions_isMonotonic(RealTemporaryDense( &W_[269], 1, 6),
   true)),"Annex60.Utilities.Math.Functions.isMonotonic(val.flowCharacteristics.phi, true)",
   "The values for phi in flowCharacteristics must be strictly monotone increasing.");
PopAllMarks();
W_[277] = W_[263];
W_[279] = W_[264];
W_[280] = W_[270];
W_[281] = W_[265];
W_[282] = W_[271];
W_[283] = W_[266];
W_[284] = W_[272];
W_[285] = W_[267];
W_[286] = W_[273];
W_[287] = W_[268];
W_[288] = W_[274];
W_[301] = DP_[92];
W_[304] = DP_[87];
W_[309] = DP_[90];
W_[310] = DP_[91];
AssertModelica(W_[309] >= W_[310],"thermostat.limiter.uMax >= thermostat.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[309], true, 0)),") < uMin (="),Real2String2(W_[310], true, 0)),
  ")"));
PopAllMarks();
W_[346] = DP_[111];
W_[347] = DP_[112];
W_[348] = DP_[113];
W_[363] = DP_[117];
W_[364] = divmacro(W_[349]*W_[363],"pump.vol.m_flow_nominal*pump.vol.tau",
  W_[356],"pump.vol.rho_default");
W_[353] = W_[364];
W_[360] = W_[347];
W_[361] = W_[346];
W_[373] = DP_[124];
W_[374] = DP_[3];
W_[384] = DP_[112];
W_[385] = DP_[111];
W_[386] = 4184*(W_[384]-273.15);
W_[398] = divmacro(5,"5",6.283185307179586*DP_[123],"6.283185307179586*pump.riseTime");
AssertModelica(W_[398] > 0,"pump.filter.f_cut > 0", "f_cut > 0 required");
W_[401] = DP_[124];
W_[402] = fabs(DP_[125]);
AssertModelica(W_[402] > 0,"pump.filter.u_nominal > 0", "u_nominal > 0 required");
W_[424] = W_[74];
W_[425] = W_[75];
W_[426] = W_[76];
W_[448] = 4184*(W_[425]-273.15);
W_[453] = W_[148];
W_[454] = W_[149];
W_[478] = 4184*(W_[454]-273.15);
W_[483] = W_[346];
W_[484] = W_[347];
W_[485] = W_[348];
W_[506] = 4184*(W_[484]-273.15);
W_[328] = 1.0044335697769957E-005;
W_[166] = DP_[39];
W_[167] = DP_[40]-0.02390057361376673*W_[166];
W_[168] = W_[167]-W_[137];
W_[169] = W_[167]-293.15;
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 0 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[0] = 343.15-W_[137];
W_[170] = divmacro(DP_[39],"rad.Q_flow_nominal",0.5*(DP_[40]+W_[135])-((1-
  DP_[38])*W_[136]+DP_[38]*W_[137]),"0.5*(rad.T_a_nominal+rad.T_b_nominal)-((1-rad.fraRad)*rad.TAir_nominal+rad.fraRad*rad.TRad_nominal)");
SolveScalarLinearParametric( -W_[171]*((1-DP_[38])*(PushModelContext(1,
  "Annex60.Utilities.Math.Functions.powerLinearized(rad.k*rad.dTRad_nominal[1], rad.n, 0.1*(rad.k*(343.15-rad.TRad_nominal)))")
  Annex60_Utilities_Math_Functions_powerLinearized(W_[171]*W_[168], DP_[41], 0.1
  *W_[171]*helpvar[0]))+DP_[38]*(PushModelContext(1,"Annex60.Utilities.Math.Functions.powerLinearized(rad.k*rad.dTCon_nominal[1], rad.n, 5.0*rad.k)")
  Annex60_Utilities_Math_Functions_powerLinearized(W_[171]*W_[169], DP_[41], 5.0
  *W_[171])))," -rad.k*((1-rad.fraRad)*Annex60.Utilities.Math.Functions.powerLinearized(rad.k*rad.dTRad_nominal[1], rad.n, 0.1*(rad.k*(343.15-rad.TRad_nominal)))+rad.fraRad*Annex60.Utilities.Math.Functions.powerLinearized(rad.k*rad.dTCon_nominal[1], rad.n, 5.0*rad.k))",
    -W_[166]," -rad.QEle_flow_nominal[1]", W_[170],"rad.UAEle");
 /* End of Equation Block */ 

W_[292] = 0.0;
PopModelContext();
  {
    W_[292] = 1.0;
  }
  RealAssign (RealTemporaryDense( &W_[330], 1, 1), RealTemporaryDense( DymArrays0,
     1, 1));
  PopAllMarks();
  RealAssign (RealTemporaryDense( &W_[331], 1, 1), RealTemporaryDense( DymArrays0,
     1, 1));
  PopAllMarks();
RealAssign (RealTemporaryDense( &W_[407], 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, pump.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, DP_[129])));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(pump.filter.cr, pump.filter.c0, pump.filter.c1, pump.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &W_[407], 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), RealTemporaryDense( 
    (Real*)(0), 1, 0), W_[398]));
  RealAssign (RealTemporaryDense( &W_[409], 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"tab\", \"C:/Users/christo/VirtualBox/modelica-annex60-issue45_benchmarks/Annex60/Experimental/Benchmarks/CentralHeatingSystem/COP_try.prn\", climateData.table, climateData.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("tab", "C:/Users/christo/VirtualBox/modelica-annex60-issue45_benchmarks/Annex60/Experimental/Benchmarks/CentralHeatingSystem/COP_try.prn",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( &DP_[134],
     1, 1), 1, 1, 1));
  W_[417] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
W_[418] = 0.0;
  {
    W_[418] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.readTableData(\nclimateData.tableID, \nfalse, \nclimateData.verboseRead)")
      Modelica_Blocks_Tables_CombiTable1D_readTableData_M(DymStruc0_construct(
      (Integer)(W_[417])), false, DP_[133]));
  }
W_[411] =  -divmacro(DP_[132],"dpSet.k",W_[402],"pump.filter.u_nominal");
PopModelContext();
W_[500] = 995.586*W_[353];
 /* Linear system of equations to solve. */
X_[3] = 0.0;
SolveScalarLinearParametric( -W_[409]," -pump.filter.r[1]",  -W_[409]*W_[411],
  " -pump.filter.r[1]*pump.filter.uu[1]", X_[3],"pump.filter.x[1]");
 /* End of Equation Block */ 

W_[392] = W_[401];
 /* Linear system of equations to solve. */
X_[4] = 0.0;
SolveScalarLinearParametric( -DP_[126]*W_[402]," -pump.filter.gain*pump.filter.u_nominal",
    -W_[392]," -pump.dp_actual", X_[4],"pump.filter.x[2]");
 /* End of Equation Block */ 

X_[1] = 995.586*DP_[13];
AssertModelica(Greater(X_[1],"exp.m", 1E-008,"1E-008", 3),"exp.m > 1E-008", 
  "Expansion vessel is undersized. You need to increase the value of the parameter V_start.");
X_[2] = X_[1]*(4184*(DP_[11]-273.15)-301.3300709330987);
X_[0] = DP_[9];
X_[5] = W_[425];
X_[6] = W_[454];
X_[7] = W_[484];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"NoName\", \"NoName\", val.phiLooUp.table, val.phiLooUp.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("NoName", "NoName", 
    RealTemporaryDense( &W_[277], 2, 6, 2), IntegerTemporaryDense( &W_[289], 1, 1),
     2, 0, 1));
  W_[291] = dummy_DymStruc0.id_0member;
PopAllMarks();
}
F_[4] = W_[410]*(X_[4]-X_[3]);
W_[299] = W_[301]*DP_[135]+DP_[99]*X_[0];
W_[302] = DP_[100]*W_[299];
W_[305] = DP_[101]*W_[302]+DP_[102]*DP_[104]+DP_[103]*DP_[105];
W_[307] = W_[304]*W_[305];
W_[253] = IF GreaterS(W_[307],"thermostat.gainPID.y", W_[309],"thermostat.limiter.uMax",
   4) THEN W_[309] ELSE IF LessS(W_[307],"thermostat.gainPID.y", W_[310],
  "thermostat.limiter.uMin", 5) THEN W_[310] ELSE W_[307];
W_[256] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nval.phiLooUp.tableID, \n1, \nval.y, \nval.phiLooUp.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[291])), 1, W_[253], W_[292]));
PopModelContext();
W_[259] = W_[256]*W_[251];
W_[261] = IF DP_[85] > 1E-015 THEN sqrtGuarded(divmacro(1,"1",divmacro(1,"1",
  sqr(W_[258]),"val.kFixed^2")+divmacro(1,"1",sqr(W_[259]),"val.kVal^2"),
  "1/val.kFixed^2+1/val.kVal^2"),"1/(1/val.kFixed^2+1/val.kVal^2)") ELSE W_[259];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
if (DymolaHomotopyLambda==0){
  BreakSectionCall(4);
}
else {
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 1. */
  /* Introducing 15 common subexpressions used in 22 expressions */
  /* Of the common subexpressions 15 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"val.dp"};
  const double nominal_[]={6000.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 1, 7);
  SetInitVectorSimple(x__, 1, W_[237], 0);
  Residues;
    helpvar[2] = divmacro(1.0,"1.0",W_[246],"val.dp_nominal_pos");
    W_[122] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(val.dp, val.k, val.m_flow_turbulent)")
      Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[237], 
      W_[261], W_[243])), helpvar[2]*0.01*W_[237]);
    PopModelContext();
    W_[28] = DP_[42]+W_[122];
    W_[36] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(pip1.port_a.m_flow, 0.00011180339887498948, 0.003)")
      Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[28], 
      0.00011180339887498948, 0.003)), 800000.0*W_[28]);
    PopModelContext();
    W_[217] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(rad.port_a.m_flow, 0.00022360679774997895, 0.003)")
      Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[122],
       0.00022360679774997895, 0.003)), 200000.0*W_[122]);
    PopModelContext();
    W_[55] = DP_[116]-W_[122];
    helpvar[3] =  -W_[55];
    W_[193] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow( -hea.port_b.m_flow, 0.00022360679774997895, 0.003)")
      Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(helpvar[3],
       0.00022360679774997895, 0.003)), (-200000.0)*W_[55]);
    PopModelContext();
    W_[52] =  -(DP_[25]+W_[55]);
    W_[97] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(hea.port_a.m_flow, 0.0031622776601683794, 0.001)")
      Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[52], 
      0.0031622776601683794, 0.001)), 1000.0*W_[52]);
    PopModelContext();
    W_[428] = DP_[10]-W_[97];
  helpvar[4] = W_[36]+DP_[10];
  SetVector(residue__, 1, W_[428]-(W_[193]+W_[392]+W_[217]+W_[237]+helpvar[4]));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  helpvar[5] = homotopy(0.0, 0.0);
  helpvar[6] = (-1.0)-helpvar[5];
  helpvar[7] = helpvar[5]*helpvar[6];
  helpvar[8] = helpvar[7]-helpvar[5]-1.0;
  helpvar[9] = helpvar[5]*helpvar[8];
  helpvar[10] = helpvar[9]+helpvar[7]-helpvar[5];
  helpvar[11] = helpvar[10]-1.0;
  helpvar[12] = helpvar[5]*helpvar[11];
  helpvar[13] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(pip1.port_a.m_flow, 0.00011180339887498948, 0.003, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[28], 0.00011180339887498948, 0.003, 1.0, 0.0, 0.0)), 800000.0)*helpvar[11]
    +helpvar[9]+helpvar[7]-helpvar[5]+helpvar[12];
  PopModelContext();
  helpvar[14] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[122], 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)), 200000.0)*helpvar[8];
  PopModelContext();
  helpvar[15] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der( -hea.port_b.m_flow, 0.00022360679774997895, 0.003, -1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    helpvar[3], 0.00022360679774997895, 0.003, -1.0, 0.0, 0.0)), -200000.0)*
    helpvar[6];
  PopModelContext();
  helpvar[16] = (helpvar[13]+helpvar[14]-(helpvar[15]+homotopy((PushModelContext(1,
    "Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(hea.port_a.m_flow, 0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[52], 0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)), 1000.0))+helpvar[5]+
    helpvar[7]-helpvar[5])*homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
    W_[261], W_[243], 1.0, 0.0, 0.0)), helpvar[2]*0.01);
  PopModelContext();
  SetMatrixLeading(Jacobian__, 1, 1, 1, helpvar[16]+helpvar[12]+helpvar[9]+
    helpvar[7]-helpvar[5]-1.0);

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  W_[237] = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



}
AssertModelica(GreaterEqual(W_[428],"hea.vol.dynBal.medium.p", 0.0,"0.0", 6),
  "hea.vol.dynBal.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("Pressure (= ",Real2String2(W_[428], true, 0)),
  " Pa) of medium \""),"Water"),"\" is negative\n(Temperature = "),Real2String2(
  X_[5], true, 0))," K)"));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(5);
W_[210] = W_[217]+W_[237]+W_[36]+DP_[10];
W_[487] = W_[392]+W_[210];
AssertModelica(GreaterEqual(W_[487],"pump.vol.dynBal.medium.p", 0.0,"0.0", 7),
  "pump.vol.dynBal.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("Pressure (= ",Real2String2(W_[487], true, 0)),
  " Pa) of medium \""),"Water"),"\" is negative\n(Temperature = "),Real2String2(
  X_[7], true, 0))," K)"));
PopAllMarks();
W_[31] = 4184*(X_[6]-273.15);
W_[173] = 273.15+0.0002390057361376673*W_[31];
W_[178] = X_[0]-W_[173];
W_[180] =  -homotopy((1-DP_[38])*W_[170]*W_[178]*(PushModelContext(1,
  "Annex60.Utilities.Math.Functions.regNonZeroPower(rad.dTCon[1], rad.n-1, 0.05)")
  Annex60_Utilities_Math_Functions_regNonZeroPower(W_[178], DP_[41]-1, 0.05)), (1
  -DP_[38])*W_[170]*powmacro(fabs(W_[169]),"abs(rad.dTCon_nominal[1])",DP_[41]-1,
  "rad.n-1")*W_[178]);
PopModelContext();
W_[15] = W_[180]*(1+DP_[48]*(X_[0]-DP_[47]));
W_[419] = DP_[136]+(IF LessTime(DP_[137], 0) THEN 0 ELSE Time-DP_[137]);
W_[413] = DP_[138]*W_[419];
W_[414] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nclimateData.tableID, \n1, \nclimateData.u[1], \nclimateData.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[417])), 1, W_[413], W_[418]));
PopModelContext();
W_[13] = 273.15+W_[414];
W_[16] = X_[0]-W_[13];
W_[14] =  -W_[17]*W_[16];
W_[12] = W_[15]+W_[14];
 /* Linear system of equations to solve. */
F_[0] = 0;
SolveScalarLinearParametric(W_[11],"room.heaCap.C", W_[12],"room.heaCap.port.Q_flow",
   F_[0],"der(room.heaCap.T)");
 /* End of Equation Block */ 

BreakSectionFunctionEnd()
BreakSectionFunctionStart(6);
if (DymolaHomotopyLambda==0){
  BreakSectionCall(7);
}
else {
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 3. */
  /* Introducing 6 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 6 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"rad.heatPortRad.T"};
  const double nominal_[]={300.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 3, 9);
  SetInitVectorSimple(x__, 1, W_[142], 288.15);
  Residues;
    W_[179] = W_[142]-W_[173];
    helpvar[19] = DP_[38]*W_[170];
    helpvar[20] = helpvar[19]*W_[179];
    helpvar[21] = DP_[41]-1;
    helpvar[22] = (PushModelContext(1,"Annex60.Utilities.Math.Functions.regNonZeroPower(rad.dTRad[1], rad.n-1, 0.05)")
      Annex60_Utilities_Math_Functions_regNonZeroPower(W_[179], helpvar[21], 
      0.05));
    PopModelContext();
    helpvar[23] = helpvar[19]*powmacro(fabs(W_[168]),"abs(rad.dTRad_nominal[1])",
      helpvar[21],"rad.n-1");
    W_[184] = homotopy(helpvar[20]*helpvar[22], helpvar[23]*W_[179]);
  helpvar[24] = 1+DP_[50]*(W_[142]-DP_[49]);
  SetVector(residue__, 1,  -W_[184]*helpvar[24]);

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  SetMatrixLeading(Jacobian__, 1, 1, 1,  -(W_[184]*DP_[50]+homotopy(helpvar[22]*
    helpvar[19]+helpvar[20]*(PushModelContext(1,"Annex60.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower(rad.dTRad[1], rad.n-1, 0.05, 1.0)")
    Annex60_Utilities_Math_Functions_BaseClasses_derx_0regNonZeroPower(W_[179], 
    helpvar[21], 0.05, 1.0)), helpvar[23])*helpvar[24]+helpvar[24]*homotopy(0.0,
     0.0)));
  PopModelContext();

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  W_[142] = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 3);
   /* End of Non-Linear Equation Block */ }



}
BreakSectionFunctionEnd()
BreakSectionFunctionStart(8);
W_[326] = W_[210]-W_[487];
W_[327] = 0.0010044335697769957*W_[122];
W_[321] = W_[326]*W_[327];
W_[388] = 99558.59999999999*W_[327];
W_[324] = (PushModelContext(1,"Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npump.hydraulicEfficiency, \npump.r_V, \npump.hydDer)")
  Annex60_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[110], 1, 1), RealTemporaryDense( &DP_[109], 1, 1)), 
  W_[388], RealTemporaryDense( &W_[331], 1, 1)));
PopAllMarks();
W_[325] = (PushModelContext(1,"Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npump.motorEfficiency, \npump.r_V, \npump.motDer)")
  Annex60_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[108], 1, 1), RealTemporaryDense( &DP_[107], 1, 1)), 
  W_[388], RealTemporaryDense( &W_[330], 1, 1)));
PopAllMarks();
W_[323] = W_[324]*W_[325];
W_[319] = divmacro(W_[321],"pump.WFlo",(PushModelContext(1,"Annex60.Utilities.Math.Functions.spliceFunction(pump.eta, 1E-005, pump.eta-1E-005, 1E-006)")
  Annex60_Utilities_Math_Functions_spliceFunction(W_[323], 1E-005, W_[323]-
  1E-005, 1E-006)),"Annex60.Utilities.Math.Functions.spliceFunction(pump.eta, 1E-005, pump.eta-1E-005, 1E-006)");
PopModelContext();
 /* Linear system of equations to solve. */
W_[320] = 0.0;
SolveScalarLinear(W_[324],"pump.etaHyd", W_[321],"pump.WFlo", W_[320],
  "pump.WHyd");
 /* End of Equation Block */ 

W_[332] = (IF DP_[106] THEN W_[319] ELSE W_[320])-W_[321];
W_[322] = homotopy((PushModelContext(1,"Annex60.Utilities.Math.Functions.spliceFunction(pump.QThe_flow, 0, noEvent(abs(pump.VMachine_flow))-2.0088671395539915E-008, 1.0044335697769957E-008)")
  Annex60_Utilities_Math_Functions_spliceFunction(W_[332], 0, fabs(W_[327])-
  2.0088671395539915E-008, 1.0044335697769957E-008)), 0);
PopModelContext();
W_[393] = DP_[126]*W_[402]*F_[4];
W_[300] = DP_[99]*F_[0];
W_[303] = DP_[100]*W_[300];
W_[306] = DP_[101]*W_[303];
W_[308] = W_[304]*W_[306];
W_[254] = IF Greater(W_[307],"thermostat.gainPID.y", W_[309],"thermostat.limiter.uMax",
   8) THEN 0.0 ELSE IF Less(W_[307],"thermostat.gainPID.y", W_[310],
  "thermostat.limiter.uMin", 9) THEN 0.0 ELSE W_[308];
W_[257] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getDerTableValue(\nval.phiLooUp.tableID, \n1, \nval.y, \nval.phiLooUp.tableOnFileRead, \nder(val.y))")
  Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(DymStruc0_construct(
  (Integer)(W_[291])), 1, W_[253], W_[292], W_[254]));
PopModelContext();
W_[260] = W_[257]*W_[251];
W_[262] = IF DP_[85] > 1E-015 THEN divmacro(divmacro(divmacro(W_[259]*W_[260],
  "val.kVal*der(val.kVal)",sqr(sqr(W_[259])),"(val.kVal^2)^2"),"val.kVal*der(val.kVal)/(val.kVal^2)^2",
  sqr(divmacro(1,"1",sqr(W_[258]),"val.kFixed^2")+divmacro(1,"1",sqr(W_[259]),
  "val.kVal^2")),"(1/val.kFixed^2+1/val.kVal^2)^2"),"val.kVal*der(val.kVal)/(val.kVal^2)^2/(1/val.kFixed^2+1/val.kVal^2)^2",
  sqrtGuarded(divmacro(1,"1",divmacro(1,"1",sqr(W_[258]),"val.kFixed^2")+
  divmacro(1,"1",sqr(W_[259]),"val.kVal^2"),"1/val.kFixed^2+1/val.kVal^2"),
  "1/(1/val.kFixed^2+1/val.kVal^2)"),"sqrt(1/(1/val.kFixed^2+1/val.kVal^2))")
   ELSE W_[260];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(9);
if (DymolaHomotopyLambda==0){
  BreakSectionCall(10);
}
else {
   /* Linear system of equations to solve. */
  /* Introducing 15 common subexpressions used in 25 expressions */
  /* Of the common subexpressions 15 are reals, 0 are integers, and 0
     are booleans. */
  helpvar[26] = homotopy(0.0, 0.0);
  helpvar[27] = (-1.0)*(1.0-helpvar[26]);
  helpvar[28] = 1.0-2.0*helpvar[26];
  helpvar[29] = helpvar[26]*helpvar[28];
  helpvar[30] = helpvar[26]+helpvar[29];
  helpvar[31] = helpvar[27]-helpvar[30];
  helpvar[32] = helpvar[31]-helpvar[26]-helpvar[29];
  helpvar[33] = helpvar[26]*helpvar[32];
  helpvar[34] = helpvar[33]-helpvar[26]+helpvar[31];
  helpvar[35] = helpvar[34]-helpvar[29];
  helpvar[36] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[122], 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)), 200000.0)*helpvar[35]
    -homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der( -hea.port_b.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der( -
    W_[55], 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)), 200000.0)+homotopy(
    (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(pip1.port_a.m_flow, 0.00011180339887498948, 0.003, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[28], 0.00011180339887498948, 0.003, 1.0, 0.0, 0.0)), 800000.0)*helpvar[32]
    -homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(hea.port_a.m_flow, 0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[52], 0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)), 1000.0)*helpvar[28];
  PopModelContext();
  helpvar[37] = divmacro(1.0,"1.0",W_[246],"val.dp_nominal_pos");
  helpvar[38] = helpvar[36]*homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, 1.0, 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
    W_[261], W_[243], 1.0, 0.0, 0.0)), helpvar[37]*0.01);
  PopModelContext();
  helpvar[39] = helpvar[35]*helpvar[26];
  helpvar[40] = helpvar[36]*homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, 0.0, der(val.k), 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
    W_[261], W_[243], 0.0, W_[262], 0.0)), 0.0);
  PopModelContext();
  W_[238] = 0.0;
  SolveScalarLinear(helpvar[38]+helpvar[39]+helpvar[33]+helpvar[31]-helpvar[29]-
    helpvar[26],"(homotopy(Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0), 200000.0)*(homotopy(0.0, 0.0)*((-1.0)*(1.0-homotopy(0.0, 0.0))-(homotopy(0.0, 0.0)+homotopy(0.0, 0.0)*(1.0-2.0*homotopy(0.0, 0.0)))-homotopy(0.0, 0.0)-homotopy(0.0, 0.0)*(1.0-2.0*homotopy(0.0, 0.0)))-homotopy(0.0, 0.0)+(-1.0)*(1.0-homotopy(0.0, 0.0))-(hom...",
     helpvar[26]-(helpvar[40]+helpvar[39]+helpvar[33]+helpvar[31]*W_[393])+
    helpvar[29],"homotopy(0.0, 0.0)-((homotopy(Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0), 200000.0)*(homotopy(0.0, 0.0)*((-1.0)*(1.0-homotopy(0.0, 0.0))-(homotopy(0.0, 0.0)+homotopy(0.0, 0.0)*(1.0-2.0*homotopy(0.0, 0.0)))-homotopy(0.0, 0.0)-homotopy(0.0, 0.0)*(1.0-2.0*homotopy(0.0, 0.0)))-homotopy(0.0, 0.0)+(-1.0)*(1.0-homo...",
     W_[238],"der(val.dp)");
  W_[29] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, der(val.dp), der(val.k), 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
    W_[261], W_[243], W_[238], W_[262], 0.0)), helpvar[37]*0.01*W_[238]);
  PopModelContext();
  W_[218] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, der(pip1.port_a.m_flow), 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[122], 0.00022360679774997895, 0.003, W_[29], 0.0, 0.0)), 200000.0*W_[29]);
  PopModelContext();
  W_[458] = homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(pip1.port_a.m_flow, 0.00011180339887498948, 0.003, der(pip1.port_a.m_flow), 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[28], 0.00011180339887498948, 0.003, W_[29], 0.0, 0.0)), 800000.0*W_[29]);
  PopModelContext();
  W_[488] = W_[218]+W_[393]+W_[238]+W_[458];
  W_[429] =  -homotopy((PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(hea.port_a.m_flow, 0.0031622776601683794, 0.001, der(pip1.port_a.m_flow), 0.0, 0.0)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
    W_[52], 0.0031622776601683794, 0.001, W_[29], 0.0, 0.0)), 1000.0*W_[29]);
  PopModelContext();
  W_[194] = W_[429]-W_[488];
   /* End of Equation Block */ 

}
BreakSectionFunctionEnd()
BreakSectionFunctionStart(11);
InitialSection
Init=false;InitializeData(2);Init=true;
InitialSection2
  AssertModelica(true,"true", "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n Set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = 30\n");
  AssertModelica(true,"true", "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.          \n Set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = 30\n");
EndInitialSection

OutputSection
AssertModelica(Greater(X_[1],"exp.m", 1E-008,"1E-008", 3),"exp.m > 1E-008", 
  "Expansion vessel is undersized. You need to increase the value of the parameter V_start.");

DynamicsSection
F_[3] = W_[409]*(X_[3]-W_[411]);
F_[4] = W_[410]*(X_[4]-X_[3]);
W_[392] = DP_[126]*W_[402]*X_[4];
W_[299] = W_[301]*DP_[135]+DP_[99]*X_[0];
W_[302] = DP_[100]*W_[299];
W_[305] = DP_[101]*W_[302]+DP_[102]*DP_[104]+DP_[103]*DP_[105];
W_[307] = W_[304]*W_[305];
W_[253] = IF GreaterS(W_[307],"thermostat.gainPID.y", W_[309],"thermostat.limiter.uMax",
   4) THEN W_[309] ELSE IF LessS(W_[307],"thermostat.gainPID.y", W_[310],
  "thermostat.limiter.uMin", 5) THEN W_[310] ELSE W_[307];
W_[256] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nval.phiLooUp.tableID, \n1, \nval.y, \nval.phiLooUp.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[291])), 1, W_[253], W_[292]));
PopModelContext();
W_[259] = W_[256]*W_[251];
W_[261] = IF DP_[85] > 1E-015 THEN sqrtGuarded(divmacro(1,"1",divmacro(1,"1",
  sqr(W_[258]),"val.kFixed^2")+divmacro(1,"1",sqr(W_[259]),"val.kVal^2"),
  "1/val.kFixed^2+1/val.kVal^2"),"1/(1/val.kFixed^2+1/val.kVal^2)") ELSE W_[259];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(12);
{ /* Non-linear system of equations to solve. */
  /* Nonlinear system of equations number = 4. */
/* Introducing 13 common subexpressions and reusing 5 variables totally used in 1
   expressions */
/* Of the common subexpressions 18 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"val.dp"};
const double nominal_[]={6000.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 4, 10, 2);
NonLinearSystemSave(W_[392], 0);
NonLinearSystemSave(W_[261], 1);
SetInitVectorNH(x__, 1, W_[237], Remember_(W_[237], 0));
Residues;
  W_[122] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(val.dp, val.k, val.m_flow_turbulent)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[237], W_[261],
     W_[243]));
  PopModelContext();
  W_[28] = DP_[42]+W_[122];
  W_[36] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(pip1.port_a.m_flow, 0.00011180339887498948, 0.003)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[28], 
    0.00011180339887498948, 0.003));
  PopModelContext();
  W_[217] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(rad.port_a.m_flow, 0.00022360679774997895, 0.003)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[122], 
    0.00022360679774997895, 0.003));
  PopModelContext();
  W_[55] = DP_[116]-W_[122];
  helpvar[41] =  -W_[55];
  W_[193] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow( -hea.port_b.m_flow, 0.00022360679774997895, 0.003)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(helpvar[41],
     0.00022360679774997895, 0.003));
  PopModelContext();
  W_[52] =  -(DP_[25]+W_[55]);
  W_[97] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(hea.port_a.m_flow, 0.0031622776601683794, 0.001)")
    Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(W_[52], 
    0.0031622776601683794, 0.001));
  PopModelContext();
  W_[428] = DP_[10]-W_[97];
helpvar[42] = W_[36]+DP_[10];
SetVector(residue__, 1, W_[428]-(W_[193]+W_[392]+W_[217]+W_[237]+helpvar[42]));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, ((-1.0)*(PushModelContext(1,
  "Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(pip1.port_a.m_flow, 0.00011180339887498948, 0.003, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[28],
   0.00011180339887498948, 0.003, 1.0, 0.0, 0.0))-(PushModelContext(1,
  "Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[122],
   0.00022360679774997895, 0.003, 1.0, 0.0, 0.0))+(PushModelContext(1,
  "Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der( -hea.port_b.m_flow, 0.00022360679774997895, 0.003, -1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(
  helpvar[41], 0.00022360679774997895, 0.003, -1.0, 0.0, 0.0))-(PushModelContext(1,
  "Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(hea.port_a.m_flow, 0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[52],
   0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)))*(PushModelContext(1,
  "Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
  W_[261], W_[243], 1.0, 0.0, 0.0))-1.0);
PopModelContext();

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 4);
W_[237] = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 4);
 /* End of Non-Linear Equation Block */ }



AssertModelica(GreaterEqual(W_[428],"hea.vol.dynBal.medium.p", 0.0,"0.0", 6),
  "hea.vol.dynBal.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("Pressure (= ",Real2String2(W_[428], true, 0)),
  " Pa) of medium \""),"Water"),"\" is negative\n(Temperature = "),Real2String2(
  X_[5], true, 0))," K)"));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(13);
W_[457] = W_[36]+DP_[10];
AssertModelica(GreaterEqual(W_[457],"rad.vol[1].dynBal.medium.p", 0.0,"0.0", 10),
  "rad.vol[1].dynBal.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("Pressure (= ",Real2String2(W_[457], true, 0)),
  " Pa) of medium \""),"Water"),"\" is negative\n(Temperature = "),Real2String2(
  X_[6], true, 0))," K)"));
PopAllMarks();
W_[210] = W_[217]+W_[237]+W_[36]+DP_[10];
W_[487] = W_[392]+W_[210];
AssertModelica(GreaterEqual(W_[487],"pump.vol.dynBal.medium.p", 0.0,"0.0", 7),
  "pump.vol.dynBal.medium.p >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd(StringAdd("Pressure (= ",Real2String2(W_[487], true, 0)),
  " Pa) of medium \""),"Water"),"\" is negative\n(Temperature = "),Real2String2(
  X_[7], true, 0))," K)"));
PopAllMarks();
W_[212] = W_[237]+W_[36]+DP_[10];
F_[1] = W_[28]-W_[52];
helpvar[43] = RealBmax(W_[28], 0.0);
helpvar[44] = RealBmax( -W_[52], 0.0);
Aux_[19] = helpvar[43]+helpvar[44];
Aux_[20] = IF Aux_[19] > 1E-010 THEN 1.0 ELSE IF Aux_[19] > 0.0 THEN sqr(
  10000000000.0*Aux_[19])*(3.0-20000000000.0*Aux_[19]) ELSE 0.0;
W_[31] = 4184*(X_[6]-273.15);
W_[53] = 4184*(X_[5]-273.15);
helpvar[45] = 1.0-Aux_[20];
helpvar[46] = 1E-010*helpvar[45];
helpvar[47] = Aux_[20]*helpvar[43]+helpvar[46];
helpvar[48] = Aux_[20]*helpvar[44]+helpvar[46];
helpvar[49] = helpvar[47]+helpvar[48];
helpvar[50] = divmacro(1.0,"1.0",helpvar[49],"stream_alpha5*max(pip1.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)+stream_alpha5*max( -hea.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha5)");
Aux_[0] = helpvar[50]*(helpvar[47]*W_[31]+helpvar[48]*W_[53]);
 /* Linear system of equations to solve. */
W_[23] = RememberSimple_(W_[23], 1);
SolveScalarLinear(X_[1],"exp.m", X_[2],"exp.H", W_[23],"exp.port_a.h_outflow");
 /* End of Equation Block */ 

F_[2] = F_[1]*(IF F_[1] > 0.0 THEN Aux_[0] ELSE W_[23]);
W_[173] = 273.15+0.0002390057361376673*W_[31];
W_[178] = X_[0]-W_[173];
helpvar[51] = (PushModelContext(1,"Annex60.Utilities.Math.Functions.regNonZeroPower(rad.dTCon[1], rad.n-1, 0.05)")
  Annex60_Utilities_Math_Functions_regNonZeroPower(W_[178], DP_[41]-1, 0.05));
PopModelContext();
W_[180] =  -(1-DP_[38])*W_[170]*W_[178]*helpvar[51];
W_[15] = W_[180]*(1+DP_[48]*(X_[0]-DP_[47]));
W_[419] = DP_[136]+(IF LessTime(DP_[137], 0) THEN 0 ELSE Time-DP_[137]);
W_[413] = DP_[138]*W_[419];
W_[414] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getTableValue(\nclimateData.tableID, \n1, \nclimateData.u[1], \nclimateData.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1D_getTableValue_M(DymStruc0_construct(
  (Integer)(W_[417])), 1, W_[413], W_[418]));
PopModelContext();
W_[13] = 273.15+W_[414];
W_[16] = X_[0]-W_[13];
W_[14] =  -W_[17]*W_[16];
W_[12] = W_[15]+W_[14];
 /* Linear system of equations to solve. */
F_[0] = RememberSimple_(F_[0], 2);
SolveScalarLinearParametric(W_[11],"room.heaCap.C", W_[12],"room.heaCap.port.Q_flow",
   F_[0],"der(room.heaCap.T)");
 /* End of Equation Block */ 

helpvar[52] = RealBmax( -F_[1], 0.0);
Aux_[17] = helpvar[43]+helpvar[52];
Aux_[18] = IF Aux_[17] > 1E-010 THEN 1.0 ELSE IF Aux_[17] > 0.0 THEN sqr(
  10000000000.0*Aux_[17])*(3.0-20000000000.0*Aux_[17]) ELSE 0.0;
helpvar[53] = 1.0-Aux_[18];
helpvar[54] = 1E-010*helpvar[53];
helpvar[55] = Aux_[18]*helpvar[43]+helpvar[54];
helpvar[56] = Aux_[18]*helpvar[52]+helpvar[54];
helpvar[57] = helpvar[55]+helpvar[56];
helpvar[58] = divmacro(1.0,"1.0",helpvar[57],"stream_alpha3*max(pip1.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha3)+stream_alpha3*max( -der(exp.m), 0.0)+1E-010*(1.0-stream_alpha3)");
W_[93] = helpvar[58]*(helpvar[55]*W_[31]+helpvar[56]*W_[23]);
W_[445] = W_[52]*(IF W_[52] > 0.0 THEN W_[93] ELSE W_[53]);
W_[188] = 4184*(X_[7]-273.15);
W_[446] = W_[55]*(IF W_[55] > 0.0 THEN W_[188] ELSE W_[53]);
W_[443] = W_[445]+W_[446];
W_[118] =  -(IF Greater(W_[52],"hea.port_a.m_flow", 0,"0", 11) THEN  -(4184*(
  DP_[56]-273.15)-W_[93])*W_[52] ELSE 0.0);
W_[440] = W_[443]+W_[118];
W_[54] = 3.3333333333333335*W_[440];
F_[5] = 0.0002390057361376673*W_[54];
W_[176] = W_[180]*(1+DP_[44]*(W_[173]-DP_[43]));
BreakSectionFunctionEnd()
BreakSectionFunctionStart(14);
{ /* Non-linear system of equations to solve. */
  /* Nonlinear system of equations number = 5. */
/* Introducing 13 common subexpressions used in 5 expressions */
/* Of the common subexpressions 13 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"rad.heatPortRad.T"};
const double nominal_[]={300.0};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 5, 11, 1);
NonLinearSystemSave(W_[173], 0);
SetInitVectorNH(x__, 1, W_[142], Remember_(W_[142], 3));
Residues;
  W_[179] = W_[142]-W_[173];
  helpvar[59] = DP_[38]*W_[170];
  helpvar[60] = helpvar[59]*W_[179];
  helpvar[61] = DP_[41]-1;
  helpvar[62] = (PushModelContext(1,"Annex60.Utilities.Math.Functions.regNonZeroPower(rad.dTRad[1], rad.n-1, 0.05)")
    Annex60_Utilities_Math_Functions_regNonZeroPower(W_[179], helpvar[61], 0.05));
  PopModelContext();
  W_[184] = helpvar[60]*helpvar[62];
helpvar[63] = 1+DP_[50]*(W_[142]-DP_[49]);
SetVector(residue__, 1,  -W_[184]*helpvar[63]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1,  -(W_[184]*DP_[50]+(helpvar[62]*helpvar[59]
  +helpvar[60]*(PushModelContext(1,"Annex60.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower(rad.dTRad[1], rad.n-1, 0.05, 1.0)")
  Annex60_Utilities_Math_Functions_BaseClasses_derx_0regNonZeroPower(W_[179], 
  helpvar[61], 0.05, 1.0)))*helpvar[63]));
PopModelContext();

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 5);
W_[142] = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 5);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunctionEnd()
BreakSectionFunctionStart(15);
W_[177] =  -W_[184]*(1+DP_[46]*(W_[173]-DP_[45]));
W_[475] = W_[122]*(IF W_[122] > 0.0 THEN W_[188] ELSE W_[31]);
Aux_[15] = helpvar[44]+helpvar[52];
Aux_[16] = IF Aux_[15] > 1E-010 THEN 1.0 ELSE IF Aux_[15] > 0.0 THEN sqr(
  10000000000.0*Aux_[15])*(3.0-20000000000.0*Aux_[15]) ELSE 0.0;
helpvar[64] = 1.0-Aux_[16];
helpvar[65] = 1E-010*helpvar[64];
helpvar[66] = Aux_[16]*helpvar[44]+helpvar[65];
helpvar[67] = Aux_[16]*helpvar[52]+helpvar[65];
helpvar[68] = helpvar[66]+helpvar[67];
helpvar[69] = divmacro(1.0,"1.0",helpvar[68],"stream_alpha1*max( -hea.port_a.m_flow, 0.0)+1E-010*(1.0-stream_alpha1)+stream_alpha1*max( -der(exp.m), 0.0)+1E-010*(1.0-stream_alpha1)");
W_[30] = helpvar[69]*(helpvar[66]*W_[53]+helpvar[67]*W_[23]);
W_[476] =  -W_[28]*(IF  -W_[28] > 0.0 THEN W_[30] ELSE W_[31]);
W_[472] = W_[475]+W_[476];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(16);
 /* Linear system of equations to solve. */
W_[174] = 4.8012961686685974E-005*(W_[472]-(W_[176]+W_[177]));

W_[32] = 4184.0*W_[174];
W_[469] = 4.97793*W_[32];
W_[157] = W_[469]-W_[472];
W_[175] = 0.05*W_[174];
 /* End of Equation Block */ 

BreakSectionFunctionEnd()
BreakSectionFunctionStart(17);
F_[6] = 0.0002390057361376673*W_[32];
W_[503] =  -W_[55]*(IF  -W_[55] > 0.0 THEN W_[53] ELSE W_[188]);
W_[504] =  -W_[122]*(IF  -W_[122] > 0.0 THEN W_[31] ELSE W_[188]);
W_[502] = W_[503]+W_[504];
W_[326] = W_[210]-W_[487];
W_[327] = 0.0010044335697769957*W_[122];
W_[321] = W_[326]*W_[327];
W_[388] = divmacro(W_[327],"pump.VMachine_flow",W_[328],"pump.V_flow_max");
W_[324] = (PushModelContext(1,"Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npump.hydraulicEfficiency, \npump.r_V, \npump.hydDer)")
  Annex60_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[110], 1, 1), RealTemporaryDense( &DP_[109], 1, 1)), 
  W_[388], RealTemporaryDense( &W_[331], 1, 1)));
PopAllMarks();
W_[325] = (PushModelContext(1,"Annex60.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npump.motorEfficiency, \npump.r_V, \npump.motDer)")
  Annex60_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DP_[108], 1, 1), RealTemporaryDense( &DP_[107], 1, 1)), 
  W_[388], RealTemporaryDense( &W_[330], 1, 1)));
PopAllMarks();
W_[323] = W_[324]*W_[325];
helpvar[70] = (PushModelContext(1,"Annex60.Utilities.Math.Functions.spliceFunction(pump.eta, 1E-005, pump.eta-1E-005, 1E-006)")
  Annex60_Utilities_Math_Functions_spliceFunction(W_[323], 1E-005, W_[323]-
  1E-005, 1E-006));
PopModelContext();
helpvar[71] = divmacro(1.0,"1.0",helpvar[70],"Annex60.Utilities.Math.Functions.spliceFunction(pump.eta, 1E-005, pump.eta-1E-005, 1E-006)");
W_[319] = helpvar[71]*W_[321];
 /* Linear system of equations to solve. */
W_[320] = RememberSimple_(W_[320], 4);
SolveScalarLinear(W_[324],"pump.etaHyd", W_[321],"pump.WFlo", W_[320],
  "pump.WHyd");
 /* End of Equation Block */ 

W_[332] = (IF DP_[106] THEN W_[319] ELSE W_[320])-W_[321];
helpvar[72] = fabs(W_[327]);
W_[322] = (PushModelContext(1,"Annex60.Utilities.Math.Functions.spliceFunction(pump.QThe_flow, 0, noEvent(abs(pump.VMachine_flow))-2*pump.delta_V_flow, pump.delta_V_flow)")
  Annex60_Utilities_Math_Functions_spliceFunction(W_[332], 0, helpvar[72]-2*
  W_[329], W_[329]));
PopModelContext();
W_[383] = W_[322]+W_[321];
W_[367] = 273.15+0.0002390057361376673*W_[188];
W_[355] = W_[383]*(1+DP_[120]*(W_[367]-DP_[119]));
W_[499] = W_[502]+W_[355];
 /* Linear system of equations to solve. */
W_[189] = RememberSimple_(W_[189], 5);
SolveScalarLinearParametric( -W_[500]," -pump.vol.dynBal.m",  -W_[499],
  " -der(pump.vol.dynBal.U)", W_[189],"der(pip2.port_a.h_outflow)");
 /* End of Equation Block */ 

F_[7] = 0.0002390057361376673*W_[189];

AcceptedSection1

AcceptedSection2
Aux_[1] = W_[30];
Aux_[12] = W_[30];
Aux_[14] = W_[31];
Aux_[2] = W_[93];
Aux_[10] = W_[188];
Aux_[9] = W_[93];
Aux_[13] = W_[53];
Aux_[11] = W_[188];
Aux_[3] = W_[188];
Aux_[4] = W_[93];
Aux_[5] = W_[188];
Aux_[6] = W_[30];
Aux_[7] = W_[53];
Aux_[8] = W_[31];
W_[461] = W_[31]-301.3300709330987;
W_[468] = 4.97793*W_[461];
W_[491] = W_[188]-301.3300709330987;
W_[498] = W_[500]*W_[491];
W_[432] = W_[53]-301.3300709330987;
W_[439] = 0.3*W_[432];
W_[393] = DP_[126]*W_[402]*F_[4];
W_[300] = DP_[99]*F_[0];
W_[303] = DP_[100]*W_[300];
W_[306] = DP_[101]*W_[303];
W_[308] = W_[304]*W_[306];
W_[254] = IF Greater(W_[307],"thermostat.gainPID.y", W_[309],"thermostat.limiter.uMax",
   8) THEN 0.0 ELSE IF Less(W_[307],"thermostat.gainPID.y", W_[310],
  "thermostat.limiter.uMin", 9) THEN 0.0 ELSE W_[308];
W_[257] = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1D.getDerTableValue(\nval.phiLooUp.tableID, \n1, \nval.y, \nval.phiLooUp.tableOnFileRead, \nder(val.y))")
  Modelica_Blocks_Tables_CombiTable1D_getDerTableValue_M(DymStruc0_construct(
  (Integer)(W_[291])), 1, W_[253], W_[292], W_[254]));
PopModelContext();
W_[260] = W_[257]*W_[251];
W_[262] = IF DP_[85] > 1E-015 THEN divmacro(divmacro(divmacro(W_[259]*W_[260],
  "val.kVal*der(val.kVal)",sqr(sqr(W_[259])),"(val.kVal^2)^2"),"val.kVal*der(val.kVal)/(val.kVal^2)^2",
  sqr(divmacro(1,"1",sqr(W_[258]),"val.kFixed^2")+divmacro(1,"1",sqr(W_[259]),
  "val.kVal^2")),"(1/val.kFixed^2+1/val.kVal^2)^2"),"val.kVal*der(val.kVal)/(val.kVal^2)^2/(1/val.kFixed^2+1/val.kVal^2)^2",
  sqrtGuarded(divmacro(1,"1",divmacro(1,"1",sqr(W_[258]),"val.kFixed^2")+
  divmacro(1,"1",sqr(W_[259]),"val.kVal^2"),"1/val.kFixed^2+1/val.kVal^2"),
  "1/(1/val.kFixed^2+1/val.kVal^2)"),"sqrt(1/(1/val.kFixed^2+1/val.kVal^2))")
   ELSE W_[260];
BreakSectionFunctionEnd()
BreakSectionFunctionStart(18);
 /* Linear system of equations to solve. */
/* Introducing 9 common subexpressions and reusing 2 variables totally used in 4
   expressions */
/* Of the common subexpressions 11 are reals, 0 are integers, and 0
   are booleans. */
helpvar[73] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der( -hea.port_b.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der( -
  W_[55], 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0));
PopModelContext();
helpvar[74] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(hea.port_a.m_flow, 0.0031622776601683794, 0.001, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[52],
   0.0031622776601683794, 0.001, 1.0, 0.0, 0.0));
PopModelContext();
helpvar[75] = helpvar[73]+helpvar[74];
helpvar[76] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, 0.0, der(val.k), 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
  W_[261], W_[243], 0.0, W_[262], 0.0));
PopModelContext();
helpvar[77] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(pip1.port_a.m_flow, 0.00011180339887498948, 0.003, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[28],
   0.00011180339887498948, 0.003, 1.0, 0.0, 0.0));
PopModelContext();
helpvar[78] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(rad.port_a.m_flow, 0.00022360679774997895, 0.003, 1.0, 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[122],
   0.00022360679774997895, 0.003, 1.0, 0.0, 0.0));
PopModelContext();
helpvar[79] = (-1.0)*helpvar[77]-helpvar[78];
/* Automatic tearing of linear system of 7 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"val.der(dp)", "pump.vol.dynBal.medium.der(p)"};
  const double nominal_[]={1, 1};
  StaticLinearSystemOfEquations(J, b, y, 2);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    helpvar[80] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, 1.0, 0.0, 0.0)")
      Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
      W_[261], W_[243], 1.0, 0.0, 0.0));
    PopModelContext();
    SetMatrixLeading(J, 1, 1, 2,  -helpvar[75]*helpvar[80]);
    SetMatrixLeading(J, 1, 2, 2, -1.0);
    SetMatrixLeading(J, 2, 1, 2, helpvar[79]*helpvar[80]-1.0);
    SetMatrixLeading(J, 2, 2, 2, 1.0);
  }
  SetVector(b, 1, helpvar[75]*helpvar[76]);
  SetVector(b, 2, W_[393]-helpvar[79]*helpvar[76]);
  SetVector(y, 1, RememberSimple_(W_[238], 6));
  SetVector(y, 2, RememberSimple_(W_[488], 7));
  SolveLinearSystemOfEquations(J, b, y, 2);
  W_[238] = GetVector(y, 1);
  W_[488] = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
W_[29] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:der(val.dp, val.k, val.m_flow_turbulent, der(val.dp), der(val.k), 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__der(W_[237], 
  W_[261], W_[243], W_[238], W_[262], 0.0));
PopModelContext();
W_[458] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(pip1.port_a.m_flow, 0.00011180339887498948, 0.003, der(pip1.port_a.m_flow), 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[28],
   0.00011180339887498948, 0.003, W_[29], 0.0, 0.0));
PopModelContext();
W_[218] = W_[488]-W_[393]-(W_[238]+W_[458]);
helpvar[81] = (PushModelContext(1,"Annex60.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow:der(hea.port_a.m_flow, 0.0031622776601683794, 0.001, der(pip1.port_a.m_flow), 0.0, 0.0)")
  Annex60_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow__der(W_[52],
   0.0031622776601683794, 0.001, W_[29], 0.0, 0.0));
PopModelContext();
W_[429] =  -helpvar[81];
W_[194] = W_[429]-W_[488];
 /* End of Equation Block */ 

BreakSectionFunctionEnd()
BreakSectionFunctionStart(19);
W_[211] = W_[488]-W_[393];
W_[213] = W_[238]+W_[458];
W_[60] = DP_[10]-W_[428];
W_[83] = 273.15+0.0002390057361376673*W_[53];
W_[127] = 273.15+0.0002390057361376673*(IF W_[122] > 0.0 THEN W_[188] ELSE 
  W_[31]);
W_[128] = 273.15+0.0002390057361376673*(IF  -W_[28] > 0.0 THEN W_[30] ELSE 
  W_[31]);
W_[293] = DP_[135]-X_[0];
W_[378] = 0.0010044335697769957*W_[122];
W_[379] = 273.15+0.0002390057361376673*W_[188];
W_[380] = 273.15+0.0002390057361376673*W_[31];
W_[437] = X_[5]-273.15;
W_[438] = 1E-005*W_[428];
W_[466] = X_[6]-273.15;
W_[467] = 1E-005*W_[457];
W_[496] = X_[7]-273.15;
W_[497] = 1E-005*W_[487];

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", \
0.0, 0.0,1E+100,100000.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("system.use_eps_Re", "= true to determine turbulent region automatically using Reynolds number [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("system.m_flow_nominal", "Default nominal mass flow rate [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("system.eps_m_flow", "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal",\
 4, 0.0001, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 5, 1, 0.0,1E+100,100000.0,0,560)
DeclareParameter("system.m_flow_small", "Default small mass flow rate for regularization of laminar and zero flow [kg/s]",\
 6, 0.01, 0.0,1E+100,0.0,0,560)
DeclareVariable("m_flow_nominal", "[kg/s]", 0.01, 0.0,0.0,0.0,0,513)
DeclareVariable("room.heaCap.C", "Heat capacity of element (= cp*m) [J/K]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareState("room.heaCap.T", "Temperature of element [K|degC]", 0, 0.0, 0.0,\
1E+100,300.0,0,544)
DeclareDerivative("room.heaCap.der(T)", "der(Temperature of element) [K/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("room.heaCap.der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "room.heaCap.der(T)", 1, 6, 0, 0)
DeclareAlias2("room.heaCap.port.T", "Port temperature [K|degC]", "room.heaCap.T", 1,\
 1, 0, 4)
DeclareVariable("room.heaCap.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("room.port_amb.T", "Port temperature [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,520)
DeclareVariable("room.port_amb.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("room.port_sou.T", "Port temperature [K|degC]", "room.heaCap.T", 1,\
 1, 0, 4)
DeclareVariable("room.port_sou.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("room.heaTranAmb.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "room.port_amb.Q_flow", -1, 5, 14, 0)
DeclareVariable("room.heaTranAmb.dT", "port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("room.heaTranAmb.port_a.T", "Port temperature [K|degC]", \
"room.heaCap.T", 1, 1, 0, 4)
DeclareAlias2("room.heaTranAmb.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.port_amb.Q_flow", -1, 5, 14, 132)
DeclareAlias2("room.heaTranAmb.port_b.T", "Port temperature [K|degC]", \
"room.port_amb.T", 1, 5, 13, 4)
DeclareAlias2("room.heaTranAmb.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.port_amb.Q_flow", 1, 5, 14, 132)
DeclareVariable("room.heaTranAmb.G", "Constant thermal conductance of material [W/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("room.UAmb", "Mean heat loss coefficient of the room to the ambient [W/(m2.K)]",\
 7, 1.0, 0.0,0.0,0.0,0,560)
DeclareVariable("room.AAmb", "Surface area of room to the ambient [m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("room.CRoom", "Total heat capacity of the room [J/K]", 8, \
2000000.0, 0.0,0.0,0.0,0,560)
DeclareParameter("room.T_start", "Start temperature of the room [K|degC]", 9, \
296.65, 0.0,1E+100,300.0,0,560)
DeclareVariable("exp.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("exp.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("exp.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("exp.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("exp.p_start", "Start value of pressure [Pa|bar]", 10, 300000, \
0.0,100000000.0,100000.0,0,560)
DeclareParameter("exp.T_start", "Start value of temperature [K|degC]", 11, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("exp.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 12, 1, 0.0,1.0,0.1,0,560)
DeclareParameter("exp.V_start", "Volume of liquid stored in the vessel at the start of the simulation [m3]",\
 13, 0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("exp.p", "Constant pressure of the expansion vessel [Pa|bar]", 14,\
 300000, 0.0,0.0,0.0,0,560)
DeclareAlias2("exp.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "exp.der(m)", 1, 6, 1, 132)
DeclareAlias2("exp.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 10, 4)
DeclareVariable("exp.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareState("exp.m", "Mass of liquid in the vessel [kg]", 1, 0.0, 0.0,1E+100,\
0.0,0,544)
DeclareDerivative("exp.der(m)", "der(Mass of liquid in the vessel) [kg/s]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("exp.state_start.T", "Temperature of medium [K|degC]", 288.15, \
0.0,1E+100,300.0,0,2561)
DeclareVariable("exp.state_start.p", "Pressure of medium [Pa|bar]", 0.0, 0.0,\
1E+100,100000.0,0,2561)
DeclareVariable("exp.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareState("exp.H", "Internal energy of fluid [J]", 2, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("exp.der(H)", "der(Internal energy of fluid) [W]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("pip1.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pip1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.01,0,776)
DeclareVariable("pip1.port_a.der(m_flow)", "der(Mass flow rate from the connection point into the component) [kg/s2]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("pip1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 4)
DeclareVariable("pip1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareAlias2("pip1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pip1.port_a.m_flow", -1, 5, 28, 132)
DeclareAlias2("pip1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 10, 4)
DeclareVariable("pip1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("pip1.port_b.der(h_outflow)", "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareParameter("pip1.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 15, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pip1.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 16, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pip1.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 17, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pip1.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("pip1.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pip1.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pip1.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "pip1.port_a.m_flow", 1, 5, 28, 0)
DeclareVariable("pip1.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,8000.0,0,512)
DeclareVariable("pip1.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip1.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 8000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pip1.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pip1.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip1.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.003, 0.0,1E+100,0.0,0,513)
DeclareParameter("pip1.sta_default.T", "Temperature of medium [K|degC]", 18, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("pip1.sta_default.p", "Pressure of medium [Pa|bar]", 19, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareVariable("pip1.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pip1.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("pip1.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 8000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pip1.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip1.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("pip1.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,1E+100,0.0,0,513)
DeclareVariable("pip1.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("pip1.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.00011180339887498948, 0.0,0.0,0.0,0,513)
DeclareVariable("pip1.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.01,0,776)
DeclareAlias2("hea.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 10, 4)
DeclareVariable("hea.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("hea.port_a.der(h_outflow)", "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("hea.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.01,0,776)
DeclareAlias2("hea.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 4)
DeclareAlias2("hea.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 4)
DeclareParameter("hea.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 20, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 21, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("hea.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "hea.port_a.m_flow", 1, 5, 52, 0)
DeclareVariable("hea.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.dp_nominal", "Pressure [Pa|Pa]", 10.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.deltaM", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 30, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("hea.p_start", "Start value of pressure [Pa|bar]", 22, 300000, \
0.0,100000000.0,100000.0,0,560)
DeclareParameter("hea.T_start", "Start value of temperature [K|degC]", 23, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("hea.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 24, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("hea.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("hea.vol.p_start", "Start value of pressure [Pa|bar]", 100000.0,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("hea.vol.T_start", "Start value of temperature [K|degC]", 300, \
1.0,10000.0,300.0,0,513)
DeclareVariable("hea.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("hea.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.vol.nPorts", "Number of ports [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("hea.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.vol.V", "Volume [m3]", 0.0003013300709330987, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_a.m_flow", 1, 5, 52, 132)
DeclareAlias2("hea.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 4)
DeclareAlias2("hea.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 4)
DeclareAlias2("hea.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", 1, 5, 55, 132)
DeclareAlias2("hea.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 4)
DeclareAlias2("hea.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 4)
DeclareVariable("hea.vol.heatPort.T", "Port temperature [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,520)
DeclareAlias2("hea.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "hea.Q_flow", 1, 5, 118, 132)
DeclareAlias2("hea.vol.T", "Temperature of the fluid [K|degC]", "hea.vol.heatPort.T", 1,\
 5, 83, 0)
DeclareAlias2("hea.vol.p", "Pressure of the fluid [Pa|bar]", "hea.vol.dynBal.medium.p", 1,\
 5, 428, 0)
DeclareVariable("hea.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareVariable("hea.vol.state_default.T", "Temperature of medium [K|degC]", \
293.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("hea.vol.state_default.p", "Pressure of medium [Pa|bar]", 300000,\
 0.0,1E+100,100000.0,0,2561)
DeclareVariable("hea.vol.state_start.T", "Temperature of medium [K|degC]", \
288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("hea.vol.state_start.p", "Pressure of medium [Pa|bar]", 0.0, 0.0,\
1E+100,100000.0,0,2561)
DeclareVariable("hea.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("hea.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 1024)
DeclareAlias2("hea.vol.QSen_flow.y", "Value of Real output [W]", "hea.Q_flow", 1,\
 5, 118, 1024)
DeclareParameter("hea.vol.masExc.k", "Constant output value [kg/s]", 25, 0, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("hea.vol.masExc.y", "Connector of Real output signal [kg/s]", \
"hea.vol.masExc.k", 1, 7, 25, 1024)
DeclareVariable("hea.preDro.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_a.m_flow", 1, 5, 52, 132)
DeclareAlias2("hea.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 10, 4)
DeclareAlias2("hea.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 4)
DeclareAlias2("hea.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_a.m_flow", -1, 5, 52, 132)
DeclareAlias2("hea.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 4)
DeclareVariable("hea.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareParameter("hea.preDro.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 26, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.preDro.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 27, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("hea.preDro.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 28, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.01, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("hea.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "hea.port_a.m_flow", 1, 5, 52, 0)
DeclareVariable("hea.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,10.0,0,512)
DeclareVariable("hea.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 10.0, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.001, 0.0,1E+100,0.0,0,513)
DeclareParameter("hea.preDro.sta_default.T", "Temperature of medium [K|degC]", 29,\
 293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("hea.preDro.sta_default.p", "Pressure of medium [Pa|bar]", 30, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareVariable("hea.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 10.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.preDro.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("hea.preDro.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.preDro.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,1E+100,0.0,0,513)
DeclareVariable("hea.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.1, 0.01,1E+100,0.0,0,513)
DeclareVariable("hea.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.0031622776601683794, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareParameter("hea.sta_default.T", "Temperature of medium [K|degC]", 31, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("hea.sta_default.p", "Pressure of medium [Pa|bar]", 32, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareVariable("hea.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.sta_start.T", "Temperature of medium [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,2561)
DeclareVariable("hea.sta_start.p", "Pressure of medium [Pa|bar]", 0.0, 0.0,\
1E+100,100000.0,0,2561)
DeclareVariable("hea.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("hea.Q_flow_maxHeat", "Maximum heat flow rate for heating (positive) [W]",\
 1E+060, 0.0,1E+060,0.0,0,513)
DeclareVariable("hea.Q_flow_maxCool", "Maximum heat flow rate for cooling (negative) [W]",\
 -1E+060, -1E+060,0.0,0.0,0,513)
DeclareAlias2("hea.TSet", "Control input (set temperature) [K]", "TSet.k", 1, 7,\
 56, 0)
DeclareVariable("hea.Q_flow", "Current heat flow rate [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("hea.preHea.Q_flow_maxHeat", "Maximum heat flow rate for heating (positive) [W]",\
 1E+060, 0.0,0.0,0.0,0,513)
DeclareVariable("hea.preHea.Q_flow_maxCool", "Maximum heat flow rate for cooling (negative) [W]",\
 -1E+060, 0.0,0.0,0.0,0,513)
DeclareAlias2("hea.preHea.TSet", "Set temperature [K]", "TSet.k", 1, 7, 56, 0)
DeclareAlias2("hea.preHea.port.T", "Port temperature [K|degC]", "hea.vol.heatPort.T", 1,\
 5, 83, 4)
DeclareAlias2("hea.preHea.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "hea.Q_flow", -1, 5, 118, 132)
DeclareAlias2("hea.preHea.h_outflow", "Specific thermodynamic enthalpy [J/kg]", \
"hea.preDro.port_b.h_outflow", 1, 5, 93, 0)
DeclareAlias2("hea.preHea.m_flow", "Mass flow rate [kg/s]", "hea.port_a.m_flow", 1,\
 5, 52, 0)
DeclareAlias2("hea.preHea.p", "Pressure [Pa|bar]", "exp.p_start", 1, 7, 10, 0)
DeclareVariable("rad.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("rad.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.01,0,776)
DeclareAlias2("rad.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 4)
DeclareAlias2("rad.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 4)
DeclareAlias2("rad.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pip1.port_a.m_flow", -1, 5, 28, 132)
DeclareAlias2("rad.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 4)
DeclareAlias2("rad.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 4)
DeclareParameter("rad.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 33, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("rad.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 34, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("rad.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 35, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("rad.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("rad.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("rad.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("rad.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 0)
DeclareVariable("rad.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("rad.sta_a.T", "Temperature of medium [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,512)
DeclareAlias2("rad.sta_a.p", "Pressure of medium [Pa|bar]", "rad.vol[1].dynBal.medium.p", 1,\
 5, 457, 0)
DeclareVariable("rad.sta_b.T", "Temperature of medium [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,512)
DeclareAlias2("rad.sta_b.p", "Pressure of medium [Pa|bar]", "rad.vol[1].dynBal.medium.p", 1,\
 5, 457, 0)
DeclareVariable("rad.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("rad.p_start", "Start value of pressure [Pa|bar]", 36, 300000, \
0.0,100000000.0,100000.0,0,560)
DeclareParameter("rad.T_start", "Start value of temperature [K|degC]", 37, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareVariable("rad.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("rad.nEle", "Number of elements used in the discretization [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareParameter("rad.fraRad", "Fraction radiant heat transfer", 38, 0, 0.0,1.0,\
0.0,0,560)
DeclareParameter("rad.Q_flow_nominal", "Nominal heating power (positive for heating) [W]",\
 39, 1500.0, 0.0,0.0,0.0,0,560)
DeclareParameter("rad.T_a_nominal", "Water inlet temperature at nominal condition [K|degC]",\
 40, 363.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("rad.T_b_nominal", "Water outlet temperature at nominal condition [K|degC]",\
 343.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("rad.TAir_nominal", "Air temperature at nominal condition [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("rad.TRad_nominal", "Radiative temperature at nominal condition [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareParameter("rad.n", "Exponent for heat transfer", 41, 1.3, 0.0,0.0,0.0,0,560)
DeclareVariable("rad.VWat", "Water volume of radiator [m3]", 0.005, 0.0,0.0,0.0,\
0,513)
DeclareVariable("rad.mDry", "Dry mass of radiator that will be lumped to water heat capacity [kg]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("rad.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("rad.QCon_flow", "Heat input into the water due to convective heat transfer with room air [W]",\
 "room.port_sou.Q_flow", -1, 5, 15, 0)
DeclareVariable("rad.QRad_flow", "Heat input into the water due to radiative heat transfer with room [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("rad.Q_flow", "Heat input into the water [W]", "room.port_sou.Q_flow", -1,\
 5, 15, 0)
DeclareAlias2("rad.heatPortCon.T", "Port temperature [K|degC]", "room.heaCap.T", 1,\
 1, 0, 4)
DeclareAlias2("rad.heatPortCon.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.port_sou.Q_flow", -1, 5, 15, 132)
DeclareVariable("rad.heatPortRad.T", "Port temperature [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,584)
DeclareVariable("rad.heatPortRad.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("rad.vol[1].energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.vol[1].massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.vol[1].substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.vol[1].traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("rad.vol[1].p_start", "Start value of pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("rad.vol[1].T_start", "Start value of temperature [K|degC]", 300,\
 1.0,10000.0,300.0,0,513)
DeclareVariable("rad.vol[1].X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,513)
DeclareVariable("rad.vol[1].m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.01, 0.0,1E+100,0.0,0,513)
DeclareVariable("rad.vol[1].nPorts", "Number of ports [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("rad.vol[1].m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("rad.vol[1].allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("rad.vol[1].V", "Volume [m3]", 0.005, 0.0,0.0,0.0,0,513)
DeclareVariable("rad.vol[1].prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("rad.vol[1].ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 132)
DeclareAlias2("rad.vol[1].ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 4)
DeclareAlias2("rad.vol[1].ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 4)
DeclareAlias2("rad.vol[1].ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pip1.port_a.m_flow", -1, 5, 28, 132)
DeclareAlias2("rad.vol[1].ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 4)
DeclareAlias2("rad.vol[1].ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 4)
DeclareAlias2("rad.vol[1].heatPort.T", "Port temperature [K|degC]", \
"rad.heaCap[1].T", 1, 5, 173, 4)
DeclareVariable("rad.vol[1].heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("rad.vol[1].T", "Temperature of the fluid [K|degC]", \
"rad.heaCap[1].T", 1, 5, 173, 0)
DeclareAlias2("rad.vol[1].p", "Pressure of the fluid [Pa|bar]", "rad.vol[1].dynBal.medium.p", 1,\
 5, 457, 0)
DeclareVariable("rad.vol[1].rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("rad.vol[1].rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("rad.vol[1].state_default.T", "Temperature of medium [K|degC]", \
293.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("rad.vol[1].state_default.p", "Pressure of medium [Pa|bar]", 300000,\
 0.0,1E+100,100000.0,0,2561)
DeclareVariable("rad.vol[1].state_start.T", "Temperature of medium [K|degC]", \
288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("rad.vol[1].state_start.p", "Pressure of medium [Pa|bar]", 0.0, \
0.0,1E+100,100000.0,0,2561)
DeclareVariable("rad.vol[1].useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("rad.vol[1].hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 1024)
DeclareAlias2("rad.vol[1].QSen_flow.y", "Value of Real output [W]", \
"rad.vol[1].heatPort.Q_flow", 1, 5, 157, 1024)
DeclareParameter("rad.vol[1].masExc.k", "Constant output value [kg/s]", 42, 0, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("rad.vol[1].masExc.y", "Connector of Real output signal [kg/s]", \
"rad.vol[1].masExc.k", 1, 7, 42, 1024)
DeclareVariable("rad.cp_nominal", "Specific heat capacity at nominal conditions [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.QEle_flow_nominal[1]", "Nominal heating power of each element [W]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.TWat_nominal[1]", "Water temperature in each element at nominal conditions [K|degC]",\
 0.0, 0.0,1E+100,300.0,0,2561)
DeclareVariable("rad.dTRad_nominal[1]", "Temperature difference for radiative heat transfer at nominal conditions [K,]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.dTCon_nominal[1]", "Temperature difference for convective heat transfer at nominal conditions [K,]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.UAEle", "UA value at nominal condition for each element [W/K]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("rad.k", "Parameter that is used to compute QEle_flow_nominal for heating or cooling mode",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.heaCap[1].C", "Heat capacity of element (= cp*m) [J/K]", \
0.05, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.heaCap[1].T", "Temperature of element [K|degC]", 0.0, 0.0,\
1E+100,300.0,0,2560)
DeclareVariable("rad.heaCap[1].der(T)", "der(Temperature of element) [K/s]", 0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("rad.heaCap[1].der_T", "Time derivative of temperature (= der(T)) [K/s]",\
 "rad.heaCap[1].der(T)", 1, 5, 174, 1024)
DeclareAlias2("rad.heaCap[1].port.T", "Port temperature [K|degC]", \
"rad.heaCap[1].T", 1, 5, 173, 1028)
DeclareVariable("rad.heaCap[1].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,2824)
DeclareParameter("rad.preCon[1].T_ref", "Reference temperature [K|degC]", 43, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("rad.preCon[1].alpha", "Temperature coefficient of heat flow rate [1/K]",\
 44, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("rad.preCon[1].Q_flow", "[W]", "rad.preSumCon.Q_flow", -1, 5, 180,\
 1024)
DeclareAlias2("rad.preCon[1].port.T", "Port temperature [K|degC]", \
"rad.heaCap[1].T", 1, 5, 173, 1028)
DeclareVariable("rad.preCon[1].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,2824)
DeclareParameter("rad.preRad[1].T_ref", "Reference temperature [K|degC]", 45, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("rad.preRad[1].alpha", "Temperature coefficient of heat flow rate [1/K]",\
 46, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("rad.preRad[1].Q_flow", "[W]", "rad.sumRad.u[1]", 1, 5, 184, 1024)
DeclareAlias2("rad.preRad[1].port.T", "Port temperature [K|degC]", \
"rad.heaCap[1].T", 1, 5, 173, 1028)
DeclareVariable("rad.preRad[1].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,2824)
DeclareVariable("rad.dTCon[1]", "Temperature difference for convective heat transfer [K,]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("rad.dTRad[1]", "Temperature difference for radiative heat transfer [K,]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("rad.QCon[1].y", "Value of Real output [W]", "rad.preSumCon.Q_flow", -1,\
 5, 180, 1024)
DeclareAlias2("rad.QRad[1].y", "Value of Real output [W]", "rad.sumRad.u[1]", 1,\
 5, 184, 1024)
DeclareParameter("rad.preSumCon.T_ref", "Reference temperature [K|degC]", 47, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("rad.preSumCon.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 48, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("rad.preSumCon.Q_flow", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("rad.preSumCon.port.T", "Port temperature [K|degC]", \
"room.heaCap.T", 1, 1, 0, 1028)
DeclareAlias2("rad.preSumCon.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.port_sou.Q_flow", -1, 5, 15, 1156)
DeclareVariable("rad.sumCon.nin", "Number of inputs [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,2565)
DeclareAlias2("rad.sumCon.u[1]", "Connector of Real input signals [W]", \
"rad.preSumCon.Q_flow", -1, 5, 180, 1024)
DeclareAlias2("rad.sumCon.y", "Connector of Real output signal [W]", \
"rad.preSumCon.Q_flow", 1, 5, 180, 1024)
DeclareVariable("rad.sumCon.k[1]", "Optional: sum coefficients", -1, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("rad.sumRad.nin", "Number of inputs [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,2565)
DeclareVariable("rad.sumRad.u[1]", "Connector of Real input signals [W]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("rad.sumRad.y", "Connector of Real output signal [W]", \
"rad.sumRad.u[1]", -1, 5, 184, 1024)
DeclareVariable("rad.sumRad.k[1]", "Optional: sum coefficients", -1, 0.0,0.0,0.0,\
0,2561)
DeclareParameter("rad.preSumRad.T_ref", "Reference temperature [K|degC]", 49, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("rad.preSumRad.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 50, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("rad.preSumRad.Q_flow", "[W]", "rad.sumRad.u[1]", -1, 5, 184, 1024)
DeclareAlias2("rad.preSumRad.port.T", "Port temperature [K|degC]", \
"rad.heatPortRad.T", 1, 5, 142, 1028)
DeclareVariable("rad.preSumRad.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("climate.port.T", "Port temperature [K|degC]", "room.port_amb.T", 1,\
 5, 13, 4)
DeclareAlias2("climate.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.port_amb.Q_flow", -1, 5, 14, 132)
DeclareAlias2("climate.T", "[K]", "room.port_amb.T", 1, 5, 13, 0)
DeclareVariable("pip2.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pip2.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", -1, 5, 55, 132)
DeclareAlias2("pip2.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 4)
DeclareVariable("pip2.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("pip2.port_a.der(h_outflow)", "der(Specific thermodynamic enthalpy close to the connection point if m_flow < 0) [m2/s3]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("pip2.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", 1, 5, 55, 132)
DeclareAlias2("pip2.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 4)
DeclareAlias2("pip2.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 4)
DeclareParameter("pip2.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 51, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pip2.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 52, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pip2.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 53, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pip2.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("pip2.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pip2.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pip2.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "hea.port_b.m_flow", -1, 5, 55, 0)
DeclareVariable("pip2.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,2000.0,0,512)
DeclareVariable("pip2.der(dp)", "der(Pressure difference between port_a and port_b) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pip2.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip2.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 2000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pip2.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pip2.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip2.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.003, 0.0,1E+100,0.0,0,513)
DeclareParameter("pip2.sta_default.T", "Temperature of medium [K|degC]", 54, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("pip2.sta_default.p", "Pressure of medium [Pa|bar]", 55, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareVariable("pip2.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pip2.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("pip2.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 2000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pip2.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip2.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("pip2.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,1E+100,0.0,0,513)
DeclareVariable("pip2.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("pip2.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.00022360679774997895, 0.0,0.0,0.0,0,513)
DeclareVariable("pip2.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareParameter("TSet.k", "Constant output value [K]", 56, 333.15, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("TSet.y", "Connector of Real output signal [K]", "TSet.k", 1, 7, 56,\
 0)
DeclareVariable("pip3.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pip3.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 132)
DeclareVariable("pip3.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,300000.0,0,520)
DeclareVariable("pip3.port_a.der(p)", "der(Thermodynamic pressure in the connection point) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("pip3.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 4)
DeclareAlias2("pip3.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", -1, 5, 122, 132)
DeclareVariable("pip3.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,300000.0,0,520)
DeclareVariable("pip3.port_b.der(p)", "der(Thermodynamic pressure in the connection point) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("pip3.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 4)
DeclareParameter("pip3.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 57, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pip3.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 58, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pip3.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 59, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pip3.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("pip3.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pip3.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pip3.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 0)
DeclareVariable("pip3.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,2000.0,0,512)
DeclareVariable("pip3.der(dp)", "der(Pressure difference between port_a and port_b) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pip3.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip3.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 2000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pip3.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pip3.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip3.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.003, 0.0,1E+100,0.0,0,513)
DeclareParameter("pip3.sta_default.T", "Temperature of medium [K|degC]", 60, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("pip3.sta_default.p", "Pressure of medium [Pa|bar]", 61, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareVariable("pip3.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pip3.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("pip3.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 2000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pip3.use_dh", "Set to true to specify hydraulic diameter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pip3.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("pip3.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,1E+100,0.0,0,513)
DeclareVariable("pip3.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("pip3.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.00022360679774997895, 0.0,0.0,0.0,0,513)
DeclareVariable("pip3.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareParameter("datVal.y[1]", "Valve position, starting with 0 and ending with 1",\
 62, 0.0, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.y[2]", "Valve position, starting with 0 and ending with 1",\
 63, 0.1667, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.y[3]", "Valve position, starting with 0 and ending with 1",\
 64, 0.3333, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.y[4]", "Valve position, starting with 0 and ending with 1",\
 65, 0.5, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.y[5]", "Valve position, starting with 0 and ending with 1",\
 66, 0.6667, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.y[6]", "Valve position, starting with 0 and ending with 1",\
 67, 1.0, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.phi[1]", "Normalized volume flow rates for the positions y",\
 68, 0.0, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.phi[2]", "Normalized volume flow rates for the positions y",\
 69, 0.2923076923076923, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.phi[3]", "Normalized volume flow rates for the positions y",\
 70, 0.5384615384615384, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.phi[4]", "Normalized volume flow rates for the positions y",\
 71, 0.6923076923076923, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.phi[5]", "Normalized volume flow rates for the positions y",\
 72, 0.7692307692307692, 0.0,1.0,0.0,0,560)
DeclareParameter("datVal.phi[6]", "Normalized volume flow rates for the positions y",\
 73, 1.0, 0.0,1.0,0.0,0,560)
DeclareVariable("val.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("val.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 132)
DeclareAlias2("val.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pip3.port_b.p", 1, 5, 212, 4)
DeclareAlias2("val.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 4)
DeclareAlias2("val.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", -1, 5, 122, 132)
DeclareAlias2("val.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 4)
DeclareAlias2("val.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 4)
DeclareParameter("val.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 74, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("val.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 75, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("val.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 76, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("val.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("val.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("val.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("val.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 0)
DeclareVariable("val.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,576)
DeclareVariable("val.der(dp)", "der(Pressure difference between port_a and port_b) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("val.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("val.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("val.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("val.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("val.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("val.sta_default.T", "Temperature of medium [K|degC]", 77, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("val.sta_default.p", "Pressure of medium [Pa|bar]", 78, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareVariable("val.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("val.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.dp_nominal_pos", "Absolute value of nominal pressure [Pa|bar]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.CvData", "Selection of flow coefficient [:#(type=Annex60.Fluid.Types.CvTypes)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("val.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 79, 0.65, 0.0,0.0,0.0,0,560)
DeclareVariable("val.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("val.Av", "Av (metric) flow coefficient [m2]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareParameter("val.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1 [1]",\
 80, 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("val.dpValve_nominal", "Nominal pressure drop of fully open valve, used if CvData=Annex60.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 1E-060, 1E-060,1E+100,0.0,0,513)
DeclareParameter("val.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 81, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("val.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("val.filteredOpening", "= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("val.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s]",\
 82, 120, 0.0,0.0,0.0,0,560)
DeclareParameter("val.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 83, 4, 1.0,4.0,0.0,0,564)
DeclareParameter("val.y_start", "Initial value of output", 84, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("val.y", "Actuator position (0: closed, 1: open)", 0.0, 0.0,1.0,\
0.0,0,512)
DeclareVariable("val.der(y)", "der(Actuator position (0: closed, 1: open))", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("val.y_actual", "Actual valve position", "val.y", 1, 5, 253, 0)
DeclareParameter("val.dpFixed_nominal", "Pressure drop of pipe and other resistances that are in series [Pa|Pa]",\
 85, 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("val.l", "Valve leakage, l=Kv(y=0)/Kv(y=1)", 1E-010, 1E-010,1.0,\
0.0,0,513)
DeclareVariable("val.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("val.der(phi)", "der(Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1))",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("val.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-060, 1E-060,1E+100,0.0,0,2560)
DeclareVariable("val.der(kVal)", "der(Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).)",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("val.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-060, 1E-060,1E+100,0.0,0,2560)
DeclareVariable("val.der(k)", "der(Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).)",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("val.flowCharacteristics.y[1]", "Valve position, starting with 0 and ending with 1",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.y[2]", "Valve position, starting with 0 and ending with 1",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.y[3]", "Valve position, starting with 0 and ending with 1",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.y[4]", "Valve position, starting with 0 and ending with 1",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.y[5]", "Valve position, starting with 0 and ending with 1",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.y[6]", "Valve position, starting with 0 and ending with 1",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.phi[1]", "Normalized volume flow rates for the positions y",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.phi[2]", "Normalized volume flow rates for the positions y",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.phi[3]", "Normalized volume flow rates for the positions y",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.phi[4]", "Normalized volume flow rates for the positions y",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.phi[5]", "Normalized volume flow rates for the positions y",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.flowCharacteristics.phi[6]", "Normalized volume flow rates for the positions y",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("val.phiLooUp.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareAlias2("val.phiLooUp.u[1]", "Connector of Real input signals", "val.y", 1,\
 5, 253, 1024)
DeclareAlias2("val.phiLooUp.y[1]", "Connector of Real output signals", "val.phi", 1,\
 5, 256, 1024)
DeclareVariable("val.phiLooUp.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("val.phiLooUp.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[6, 1]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("val.phiLooUp.table[6, 2]", "Table matrix (grid = first column; e.g., table=[0,2])",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("val.phiLooUp.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 86, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("val.phiLooUp.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("val.phiLooUp.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 2, 1.0,3.0,0.0,0,2565)
DeclareVariable("val.phiLooUp.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2565)
DeclareVariable("val.phiLooUp.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("thermostat.u_s", "Connector of setpoint input signal [K]", \
"TAirSet.k", 1, 7, 135, 0)
DeclareAlias2("thermostat.u_m", "Connector of measurement input signal [K]", \
"room.heaCap.T", 1, 1, 0, 0)
DeclareAlias2("thermostat.y", "Connector of actuator output signal", "val.y", 1,\
 5, 253, 0)
DeclareVariable("thermostat.controlError", "Control error (set point - measurement) [K]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("thermostat.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("thermostat.k", "Gain of controller [1]", 87, 0.5, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("thermostat.Ti", "Time constant of Integrator block [s]", 88, \
0.5, 1E-060,1E+100,0.0,0,560)
DeclareParameter("thermostat.Td", "Time constant of Derivative block [s]", 89, \
0.1, 0.0,1E+100,0.0,0,560)
DeclareParameter("thermostat.yMax", "Upper limit of output", 90, 1.0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("thermostat.yMin", "Lower limit of output", 91, 0.0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("thermostat.wp", "Set-point weight for Proportional block (0..1)",\
 92, 1.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("thermostat.wd", "Set-point weight for Derivative block (0..1)",\
 93, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("thermostat.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 94, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("thermostat.Nd", "The higher Nd, the more ideal the derivative block",\
 95, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("thermostat.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("thermostat.limitsAtInit", "= false, if limits are ignored during initialization [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("thermostat.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 96, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("thermostat.xd_start", "Initial or guess value for state of derivative block",\
 97, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("thermostat.y_start", "Initial value of output", 98, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("thermostat.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("thermostat.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("thermostat.addP.u1", "Connector of Real input signal 1 [K]", \
"TAirSet.k", 1, 7, 135, 0)
DeclareAlias2("thermostat.addP.u2", "Connector of Real input signal 2 [K]", \
"room.heaCap.T", 1, 1, 0, 0)
DeclareVariable("thermostat.addP.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("thermostat.addP.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("thermostat.addP.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("thermostat.addP.k2", "Gain of lower input", 99, -1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("thermostat.P.k", "Gain value multiplied with input signal [1]",\
 100, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("thermostat.P.u", "Input signal connector", "thermostat.addP.y", 1,\
 5, 299, 0)
DeclareVariable("thermostat.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("thermostat.P.der(y)", "der(Output signal connector)", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("thermostat.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("thermostat.gainPID.u", "Input signal connector", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("thermostat.gainPID.der(u)", "der(Input signal connector)", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("thermostat.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("thermostat.gainPID.der(y)", "der(Output signal connector)", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareParameter("thermostat.addPID.k1", "Gain of upper input", 101, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("thermostat.addPID.k2", "Gain of middle input", 102, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("thermostat.addPID.k3", "Gain of lower input", 103, 1, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("thermostat.addPID.u1", "Connector 1 of Real input signals", \
"thermostat.P.y", 1, 5, 302, 0)
DeclareAlias2("thermostat.addPID.u2", "Connector 2 of Real input signals", \
"thermostat.Dzero.k", 1, 7, 104, 0)
DeclareAlias2("thermostat.addPID.u3", "Connector 3 of Real input signals", \
"thermostat.Izero.k", 1, 7, 105, 0)
DeclareAlias2("thermostat.addPID.y", "Connector of Real output signals", \
"thermostat.gainPID.u", 1, 5, 305, 0)
DeclareVariable("thermostat.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("thermostat.limiter.uMin", "Lower limits of input signals", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("thermostat.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("thermostat.limiter.limitsAtInit", "= false, if limits are ignored during initialization (i.e., y=u) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("thermostat.limiter.u", "Connector of Real input signal", \
"thermostat.gainPID.y", 1, 5, 307, 0)
DeclareAlias2("thermostat.limiter.y", "Connector of Real output signal", "val.y", 1,\
 5, 253, 0)
DeclareVariable("thermostat.with_I", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("thermostat.with_D", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("thermostat.Dzero.k", "Constant output value", 104, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("thermostat.Dzero.y", "Connector of Real output signal", \
"thermostat.Dzero.k", 1, 7, 104, 0)
DeclareParameter("thermostat.Izero.k", "Constant output value", 105, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("thermostat.Izero.y", "Connector of Real output signal", \
"thermostat.Izero.k", 1, 7, 105, 0)
DeclareAlias2("tempSen.T", "Absolute temperature as output signal [K]", \
"room.heaCap.T", 1, 1, 0, 0)
DeclareAlias2("tempSen.port.T", "Port temperature [K|degC]", "room.heaCap.T", 1,\
 1, 0, 4)
DeclareVariable("tempSen.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("pump.use_powerCharacteristic", "Use powerCharacteristic (vs. efficiencyCharacteristic) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("pump.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 106, true, 0.0,0.0,0.0,0,562)
DeclareVariable("pump.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pump.motorEfficiency.r_V[1]", "Volumetric flow rate divided by nominal flow rate at user-selected operating points [|1]",\
 107, 1, 0.0,1.0,0.0,0,560)
DeclareParameter("pump.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 108, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("pump.hydraulicEfficiency.r_V[1]", "Volumetric flow rate divided by nominal flow rate at user-selected operating points [|1]",\
 109, 1, 0.0,1.0,0.0,0,560)
DeclareParameter("pump.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [|1]",\
 110, 0.7, 0.0,1.0,0.0,0,560)
DeclareVariable("pump.rho_default", "Fluid density at medium default state [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,513)
DeclareVariable("pump.P", "Electrical power consumed [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump.WHyd", "Hydraulic power input (converted to flow work and heat) [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump.WFlo", "Flow work [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump.Q_flow", "Heat input from fan or pump to medium [W]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("pump.eta", "Global efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("pump.etaHyd", "Hydraulic efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("pump.etaMot", "Motor efficiency [1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareVariable("pump.dpMachine", "Pressure increase [Pa|Pa]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump.VMachine_flow", "Volume flow rate [m3/s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("pump.V_flow_max", "Maximum volume flow rate, used for smoothing [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.delta_V_flow", "Factor used for setting heat input into medium to zero at very small flows [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.motDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.hydDer[1]", "Coefficients for polynomial of pressure vs. flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.QThe_flow", "Heat input from fan or pump to medium [W]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pump.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("pump.p_start", "Start value of pressure [Pa|bar]", 111, 300000,\
 0.0,100000000.0,100000.0,0,560)
DeclareParameter("pump.T_start", "Start value of temperature [K|degC]", 112, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("pump.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 113, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("pump.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pump.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", -1, 5, 55, 132)
DeclareAlias2("pump.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 4)
DeclareAlias2("pump.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 4)
DeclareAlias2("pump.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", -1, 5, 122, 132)
DeclareAlias2("pump.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pip3.port_a.p", 1, 5, 210, 4)
DeclareAlias2("pump.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 4)
DeclareParameter("pump.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 114, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("pump.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 115, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("pump.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01, \
0.0,0.0,0.0,0,513)
DeclareVariable("pump.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pump.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pump.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "hea.port_b.m_flow", -1, 5, 55, 0)
DeclareAlias2("pump.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 "pump.dpMachine", -1, 5, 326, 0)
DeclareVariable("pump.vol.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.vol.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.vol.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.vol.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("pump.vol.p_start", "Start value of pressure [Pa|bar]", 100000.0,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("pump.vol.T_start", "Start value of temperature [K|degC]", 300, \
1.0,10000.0,300.0,0,513)
DeclareVariable("pump.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("pump.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.01,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("pump.vol.nPorts", "Number of ports [:#(type=Integer)]", 2, \
0.0,0.0,0.0,0,517)
DeclareVariable("pump.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, 0.0,1E+100,0.0,0,513)
DeclareVariable("pump.vol.allowFlowReversal", "= true to allow flow reversal in medium, false restricts to design direction (ports[1] -> ports[2]). Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pump.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("pump.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", -1, 5, 55, 132)
DeclareAlias2("pump.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 4)
DeclareAlias2("pump.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 4)
DeclareAlias2("pump.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", -1, 5, 122, 132)
DeclareAlias2("pump.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 4)
DeclareAlias2("pump.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 4)
DeclareAlias2("pump.vol.heatPort.T", "Port temperature [K|degC]", \
"pump.heatPort.T", 1, 5, 367, 4)
DeclareVariable("pump.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("pump.vol.T", "Temperature of the fluid [K|degC]", \
"pump.heatPort.T", 1, 5, 367, 0)
DeclareAlias2("pump.vol.p", "Pressure of the fluid [Pa|bar]", "pump.vol.dynBal.medium.p", 1,\
 5, 487, 0)
DeclareVariable("pump.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pump.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pump.vol.state_default.T", "Temperature of medium [K|degC]", \
293.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("pump.vol.state_default.p", "Pressure of medium [Pa|bar]", 300000,\
 0.0,1E+100,100000.0,0,2561)
DeclareVariable("pump.vol.state_start.T", "Temperature of medium [K|degC]", \
288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("pump.vol.state_start.p", "Pressure of medium [Pa|bar]", 0.0, \
0.0,1E+100,100000.0,0,2561)
DeclareVariable("pump.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pump.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 1024)
DeclareAlias2("pump.vol.QSen_flow.y", "Value of Real output [W]", \
"pump.vol.heatPort.Q_flow", 1, 5, 355, 1024)
DeclareParameter("pump.vol.masExc.k", "Constant output value [kg/s]", 116, 0, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("pump.vol.masExc.y", "Connector of Real output signal [kg/s]", \
"pump.vol.masExc.k", 1, 7, 116, 1024)
DeclareVariable("pump.vol.tau", "Time constant at nominal flow [s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pump.vol.V_nominal", "Volume of delay element [m3]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pump.dynamicBalance", "Set to true to use a dynamic balance, which often leads to smaller systems of equations [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("pump.addPowerToMedium", "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pump.tau", "Time constant of fluid volume for nominal flow, used if dynamicBalance=true [s]",\
 117, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("pump.heatPort.T", "Port temperature [K|degC]", 288.15, 0.0,\
1E+100,300.0,0,520)
DeclareVariable("pump.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("pump.rho_in", "Density of inflowing fluid [kg/m3|g/cm3]", \
995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pump.preSou.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pump.preSou.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 1156)
DeclareAlias2("pump.preSou.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 1028)
DeclareAlias2("pump.preSou.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 1028)
DeclareAlias2("pump.preSou.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", -1, 5, 122, 1156)
DeclareAlias2("pump.preSou.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pip3.port_a.p", 1, 5, 210, 1028)
DeclareAlias2("pump.preSou.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 1028)
DeclareVariable("pump.preSou.port_a_exposesState", "= true if port_a exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump.preSou.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("pump.preSou.showDesignFlowDirection", "= false to hide the arrow in the model icon [:#(type=Boolean)]",\
 118, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pump.preSou.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pump.preSou.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("pump.preSou.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 1.0000000000000002E-006, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("pump.preSou.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump.preSou.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pump.preSou.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 1024)
DeclareAlias2("pump.preSou.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|bar]",\
 "pump.dp_actual", 1, 5, 392, 1024)
DeclareVariable("pump.preSou.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pump.preSou.state_a.T", "Temperature of medium [K|degC]", \
288.15, 0.0,1E+100,300.0,0,2560)
DeclareAlias2("pump.preSou.state_a.p", "Pressure of medium [Pa|bar]", \
"pump.vol.dynBal.medium.p", 1, 5, 487, 1024)
DeclareVariable("pump.preSou.state_b.T", "Temperature of medium [K|degC]", \
288.15, 0.0,1E+100,300.0,0,2560)
DeclareAlias2("pump.preSou.state_b.p", "Pressure of medium [Pa|bar]", \
"pip3.port_a.p", 1, 5, 210, 1024)
DeclareVariable("pump.preSou.control_m_flow", "= false to control dp instead of m_flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump.preSou.m_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pump.preSou.dp_internal", "Needed to connect to conditional connector [Pa]",\
 "pump.dp_actual", 1, 5, 392, 1024)
DeclareParameter("pump.prePow.T_ref", "Reference temperature [K|degC]", 119, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("pump.prePow.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 120, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("pump.prePow.Q_flow", "[W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pump.prePow.port.T", "Port temperature [K|degC]", \
"pump.heatPort.T", 1, 5, 367, 1028)
DeclareAlias2("pump.prePow.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pump.vol.heatPort.Q_flow", -1, 5, 355, 1156)
DeclareVariable("pump.sta_start.T", "Temperature of medium [K|degC]", 288.15, \
0.0,1E+100,300.0,0,2561)
DeclareVariable("pump.sta_start.p", "Pressure of medium [Pa|bar]", 0.0, 0.0,\
1E+100,100000.0,0,2561)
DeclareVariable("pump.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.control_m_flow", "= false to control head instead of m_flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pump.r_V", "Ratio V_flow/V_flow_max = V_flow/V_flow(dp=0, N=N_nominal) [1]",\
 1, 0.0,0.0,0.0,0,512)
DeclareVariable("pump.p_a_default", "Nominal inlet pressure for predefined fan or pump characteristics [Pa|Pa]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareParameter("pump.sta_default.T", "Temperature of medium [K|degC]", 121, \
293.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("pump.sta_default.p", "Pressure of medium [Pa|bar]", 122, 300000,\
 0.0,1E+100,100000.0,0,2608)
DeclareAlias2("pump.PToMedium_flow.y", "Value of Real output [W]", \
"pump.prePow.Q_flow", 1, 5, 383, 1024)
DeclareVariable("pump.filteredSpeed", "= true, if speed is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pump.riseTime", "Rise time of the filter (time to reach 99.6 % of the speed) [s]",\
 123, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("pump.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("pump.dp_start", "Initial value of pressure raise [Pa|Pa]", 124,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pump.dp_nominal", "Nominal pressure raise, used to normalize filter [Pa|Pa]",\
 125, 10000, 0.0,1E+100,0.0,0,560)
DeclareAlias2("pump.dp_in", "Prescribed pressure rise [Pa]", "dpSet.k", 1, 7, 132,\
 0)
DeclareVariable("pump.dp_actual", "[Pa]", 0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("pump.der(dp_actual)", "[Pa/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pump.gain.k", "Gain value multiplied with input signal [1]", -1,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("pump.gain.u", "Input signal connector [Pa]", "dpSet.k", 1, 7, 132,\
 1024)
DeclareAlias2("pump.gain.y", "Output signal connector [Pa]", "dpSet.k", -1, 7, 132,\
 1024)
DeclareAlias2("pump.filter.u", "Connector of Real input signal [Pa]", "dpSet.k", -1,\
 7, 132, 1024)
DeclareAlias2("pump.filter.y", "Connector of Real output signal [Pa]", \
"pump.dp_actual", 1, 5, 392, 1024)
DeclareVariable("pump.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.filter.order", "Order of filter [:#(type=Integer)]", 2, \
1.0,1E+100,0.0,0,2565)
DeclareVariable("pump.filter.f_cut", "Cut-off frequency [Hz]", 0.0, 0.0,0.0,0.0,\
0,2561)
DeclareParameter("pump.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 126, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pump.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 127, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("pump.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 128, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pump.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 129, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pump.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.filter.nx", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("pump.filter.x_start[1]", "Initial or guess values of states", 130,\
 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pump.filter.x_start[2]", "Initial or guess values of states", 131,\
 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("pump.filter.y_start", "Initial value of output [Pa]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pump.filter.u_nominal", "Nominal value of input (used for scaling the states) [Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareState("pump.filter.x[1]", "Filter states", 3, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pump.filter.der(x[1])", "der(Filter states)", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareState("pump.filter.x[2]", "Filter states", 4, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pump.filter.der(x[2])", "der(Filter states)", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("pump.filter.ncr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pump.filter.nc0", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pump.filter.na", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pump.filter.nr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pump.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.filter.uu[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pump.filter.uu[2]", "", "pump.filter.x[1]", 1, 1, 3, 1024)
DeclareAlias2("pump.filter.uu[3]", "", "pump.filter.x[2]", 1, 1, 4, 1024)
DeclareAlias2("pump.dp_filtered", "Filtered pressure [Pa]", "pump.dp_actual", 1,\
 5, 392, 1024)
DeclareParameter("dpSet.k", "Constant output value [Pa]", 132, 12000.0, 0.0,\
1E+100,0.0,0,560)
DeclareAlias2("dpSet.y", "Connector of Real output signal [Pa]", "dpSet.k", 1, 7,\
 132, 0)
DeclareVariable("climateData.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("climateData.u[1]", "Connector of Real input signals [s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("climateData.y[1]", "Connector of Real output signals [degC]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("climateData.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("climateData.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 133, true, 0.0,0.0,0.0,0,562)
DeclareParameter("climateData.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 134, 2, 0.0,0.0,0.0,0,564)
DeclareVariable("climateData.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("climateData.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("climateData.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("from_degC.u", "Connector of Real input signal to be converted [degC]",\
 "climateData.y[1]", 1, 5, 414, 0)
DeclareAlias2("from_degC.y", "Connector of Real output signal containing input signal u in another unit [K]",\
 "room.port_amb.T", 1, 5, 13, 0)
DeclareParameter("TAirSet.k", "Constant output value [K]", 135, 295.15, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("TAirSet.y", "Connector of Real output signal [K]", "TAirSet.k", 1,\
 7, 135, 0)
DeclareParameter("clock.offset", "Offset of output signal [s]", 136, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("clock.startTime", "Output = offset for time < startTime [s]", 137,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("clock.y", "Connector of Real output signal [s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareParameter("gain.k", "Gain value multiplied with input signal [1]", 138, \
0.0002777777777777778, 0.0,0.0,0.0,0,560)
DeclareAlias2("gain.u", "Input signal connector [s]", "clock.y", 1, 5, 419, 0)
DeclareAlias2("gain.y", "Output signal connector [s]", "climateData.u[1]", 1, 5,\
 413, 0)
DeclareVariable("hea.vol.dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("hea.vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("hea.vol.dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("hea.vol.dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("hea.vol.dynBal.p_start", "Start value of pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("hea.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("hea.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("hea.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,2565)
DeclareAlias2("hea.vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_a.m_flow", 1, 5, 52, 1156)
DeclareAlias2("hea.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 1028)
DeclareAlias2("hea.vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 1028)
DeclareAlias2("hea.vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", 1, 5, 55, 1156)
DeclareAlias2("hea.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "hea.vol.dynBal.medium.p", 1, 5, 428, 1028)
DeclareAlias2("hea.vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 1028)
DeclareVariable("hea.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,300000.0,0,2560)
DeclareVariable("hea.vol.dynBal.medium.der(p)", "der(Absolute pressure of medium) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("hea.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]", \
"hea.port_a.h_outflow", 1, 5, 53, 1024)
DeclareVariable("hea.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]", \
995.586, 0.0,100000.0,1.0,0,2561)
DeclareState("hea.vol.dynBal.medium.T", "Temperature of medium [K|degC]", 5, \
293.15, 1.0,10000.0,293.15,0,2592)
DeclareDerivative("hea.vol.dynBal.medium.der(T)", "der(Temperature of medium) [K/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("hea.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,2560)
DeclareVariable("hea.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 8.314472, 0.0,10000000.0,1000.0,0,2561)
DeclareVariable("hea.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,2561)
DeclareAlias2("hea.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "hea.vol.dynBal.medium.T", 1, 1, 5, 1024)
DeclareAlias2("hea.vol.dynBal.medium.state.p", "Pressure of medium [Pa|bar]", \
"hea.vol.dynBal.medium.p", 1, 5, 428, 1024)
DeclareVariable("hea.vol.dynBal.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.vol.dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("hea.vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.vol.dynBal.U", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("hea.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.vol.dynBal.m", "Mass of fluid [kg]", 0.3, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("hea.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]", \
"hea.vol.masExc.k", -1, 7, 25, 1024)
DeclareVariable("hea.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("hea.vol.dynBal.fluidVolume", "Volume [m3]", 0.0003013300709330987,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("hea.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transfered into the medium [W]",\
 "hea.Q_flow", 1, 5, 118, 1024)
DeclareAlias2("hea.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 "hea.vol.masExc.k", 1, 7, 25, 1024)
DeclareAlias2("hea.vol.dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "hea.port_a.h_outflow", 1, 5, 53, 1024)
DeclareParameter("hea.vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 139, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("hea.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("hea.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("hea.vol.dynBal.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("hea.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("rad.vol[1].dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("rad.vol[1].dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("rad.vol[1].dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("rad.vol[1].dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("rad.vol[1].dynBal.p_start", "Start value of pressure [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("rad.vol[1].dynBal.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("rad.vol[1].dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("rad.vol[1].dynBal.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareAlias2("rad.vol[1].dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", 1, 5, 122, 1156)
DeclareAlias2("rad.vol[1].dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 1028)
DeclareAlias2("rad.vol[1].dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 1028)
DeclareAlias2("rad.vol[1].dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "pip1.port_a.m_flow", -1, 5, 28, 1156)
DeclareAlias2("rad.vol[1].dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 1028)
DeclareAlias2("rad.vol[1].dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 1028)
DeclareVariable("rad.vol[1].dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,300000.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.medium.der(p)", "der(Absolute pressure of medium) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("rad.vol[1].dynBal.medium.h", "Specific enthalpy of medium [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 1024)
DeclareVariable("rad.vol[1].dynBal.medium.d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,100000.0,1.0,0,2561)
DeclareState("rad.vol[1].dynBal.medium.T", "Temperature of medium [K|degC]", 6, \
293.15, 1.0,10000.0,293.15,0,2592)
DeclareDerivative("rad.vol[1].dynBal.medium.der(T)", "der(Temperature of medium) [K/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("rad.vol[1].dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 8.314472, 0.0,10000000.0,1000.0,0,2561)
DeclareVariable("rad.vol[1].dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,2561)
DeclareAlias2("rad.vol[1].dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "rad.vol[1].dynBal.medium.T", 1, 1, 6, 1024)
DeclareAlias2("rad.vol[1].dynBal.medium.state.p", "Pressure of medium [Pa|bar]",\
 "rad.vol[1].dynBal.medium.p", 1, 5, 457, 1024)
DeclareVariable("rad.vol[1].dynBal.medium.preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("rad.vol[1].dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("rad.vol[1].dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.U", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.der(U)", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.m", "Mass of fluid [kg]", 4.97793, 0.0,1E+100,\
0.0,0,2561)
DeclareVariable("rad.vol[1].dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("rad.vol[1].dynBal.mb_flow", "Mass flows across boundaries [kg/s]",\
 "rad.vol[1].masExc.k", -1, 7, 42, 1024)
DeclareVariable("rad.vol[1].dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.fluidVolume", "Volume [m3]", 0.005, 0.0,0.0,\
0.0,0,2561)
DeclareAlias2("rad.vol[1].dynBal.Q_flow", "Sensible plus latent heat flow rate transfered into the medium [W]",\
 "rad.vol[1].heatPort.Q_flow", 1, 5, 157, 1024)
DeclareAlias2("rad.vol[1].dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 "rad.vol[1].masExc.k", 1, 7, 42, 1024)
DeclareAlias2("rad.vol[1].dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "pip1.port_b.h_outflow", 1, 5, 31, 1024)
DeclareVariable("rad.vol[1].dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("rad.vol[1].dynBal.ports_H_flow[1]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.ports_H_flow[2]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("rad.vol[1].dynBal.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("rad.vol[1].dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pump.vol.dynBal.energyDynamics", "Formulation of energy balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.vol.dynBal.massDynamics", "Formulation of mass balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.vol.dynBal.substanceDynamics", "Formulation of substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.vol.dynBal.traceDynamics", "Formulation of trace substance balance [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pump.vol.dynBal.p_start", "Start value of pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pump.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 300, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pump.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("pump.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,2565)
DeclareAlias2("pump.vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "hea.port_b.m_flow", -1, 5, 55, 1156)
DeclareAlias2("pump.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 1028)
DeclareAlias2("pump.vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 1028)
DeclareAlias2("pump.vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "rad.port_a.m_flow", -1, 5, 122, 1156)
DeclareAlias2("pump.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pump.vol.dynBal.medium.p", 1, 5, 487, 1028)
DeclareAlias2("pump.vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 1028)
DeclareVariable("pump.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,300000.0,0,2560)
DeclareVariable("pump.vol.dynBal.medium.der(p)", "der(Absolute pressure of medium) [Pa/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pump.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]", \
"pip2.port_a.h_outflow", 1, 5, 188, 1024)
DeclareVariable("pump.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]", \
995.586, 0.0,100000.0,1.0,0,2561)
DeclareState("pump.vol.dynBal.medium.T", "Temperature of medium [K|degC]", 7, \
293.15, 1.0,10000.0,293.15,0,2592)
DeclareDerivative("pump.vol.dynBal.medium.der(T)", "der(Temperature of medium) [K/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pump.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("pump.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 0.0, -100000000.0,100000000.0,1000000.0,0,2560)
DeclareVariable("pump.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 8.314472, 0.0,10000000.0,1000.0,0,2561)
DeclareVariable("pump.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,2561)
DeclareAlias2("pump.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "pump.vol.dynBal.medium.T", 1, 1, 7, 1024)
DeclareAlias2("pump.vol.dynBal.medium.state.p", "Pressure of medium [Pa|bar]", \
"pump.vol.dynBal.medium.p", 1, 5, 487, 1024)
DeclareVariable("pump.vol.dynBal.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump.vol.dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pump.vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pump.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pump.vol.dynBal.U", "Internal energy of fluid [J]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("pump.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pump.vol.dynBal.m", "Mass of fluid [kg]", 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pump.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pump.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]", \
"pump.vol.masExc.k", -1, 7, 116, 1024)
DeclareVariable("pump.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pump.vol.dynBal.fluidVolume", "Volume [m3]", "pump.vol.V", 1, 5, 353,\
 1024)
DeclareAlias2("pump.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transfered into the medium [W]",\
 "pump.vol.heatPort.Q_flow", 1, 5, 355, 1024)
DeclareAlias2("pump.vol.dynBal.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 "pump.vol.masExc.k", 1, 7, 116, 1024)
DeclareAlias2("pump.vol.dynBal.hOut", "Leaving enthalpy of the component [J/kg]",\
 "pip2.port_a.h_outflow", 1, 5, 188, 1024)
DeclareParameter("pump.vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 140, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("pump.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("pump.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, -100000000.0,\
100000000.0,1000.0,0,2560)
DeclareVariable("pump.vol.dynBal.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pump.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pump.preSou.dp_in", "Prescribed outlet pressure [Pa]", \
"pump.dp_actual", 1, 5, 392, 1024)
EndNonAlias(0)
#define NX_    8
#define NX2_   5
#define NU_    0
#define NY_    0
#define NW_    507
#define NP_    141
#define NPS_   0
#define MAXAuxStr_   5
#define MAXAuxStrLen_   500
#define NHash1_ -610204213
#define NHash2_ 1218464015
#define NHash3_ 0
#define NI_    0
#define NRelF_ 12
#define NRel_  12
#define NTim_  1
#define NSamp_ 0
#define NCons_ 0
#define NA_    212
#define SizePre_ 0
#define SizeEq_ 8
#define SizeDelay_ 0
#define QNLmax_ 5
#define MAXAux 21
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 82
#ifndef NExternalObject_
#define NExternalObject_ 2
#endif

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double *time, double X_[], double XD_[], double U_[], 
double DP_[], long IP_[], Dymola_bool LP_[], double F_[], double Y_[], double W_[], double QZ_[], double duser_[], long iuser_[], void*cuser_[]) {
static Real initStore[3];
if (HReject) W_[142]=initStore[0]; else initStore[0]=W_[142];
if (HReject) W_[237]=initStore[1]; else initStore[1]=W_[237];
}
StartDataBlock
StartEqBlock
DoRemember_(W_[189], 0.0, 5);
DoRemember_(W_[488], 0.0, 7);
DoRemember_(F_[0], 0, 2);
DoRemember_(W_[238], 0.0, 6);
DoRemember_(W_[23], 0.0, 1);
DoRemember_(W_[320], 0.0, 4);
DoRemember_(W_[142], 288.15, 3);
DoRemember_(W_[237], 0, 0);
EndEqBlock
EndDataBlock
  BreakSectionStart(4);
   /* Linear system of equations to solve. */
  /* Introducing 1 common subexpressions used in 3 expressions */
  /* Of the common subexpressions 1 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 10 simultaneous equations
  gave a linear system of 2 equations for numerical solution.*/
  {
    const char*const varnames_[]={"pip2.dp", "val.dp"};
    const double nominal_[]={2000.0, 6000.0};
    StaticLinearSystemOfEquations(J, b, y, 2);
    /* Parameter dependent Jacobian */
    if (NewParameters) SetNeedFactor(J);
    if (NeedFactor(J)) {
      MatrixZeros(J);
      helpvar[1] = divmacro(1.0,"1.0",W_[246],"val.dp_nominal_pos");
      SetMatrixLeading(J, 1, 1, 2, -1.25625E-006);
      SetMatrixLeading(J, 1, 2, 2, helpvar[1]*(-0.0125)-1.25E-006);
      SetMatrixLeading(J, 2, 1, 2, -5E-006);
      SetMatrixLeading(J, 2, 2, 2, helpvar[1]*0.01);
    }
    SetVector(b, 1, DP_[42]-(0.00125*DP_[25]+1.25E-006*DP_[10])+1.25E-006*(
      W_[392]+DP_[10]));
    SetVector(b, 2, DP_[116]);
    SetVector(y, 1, 0);
    SetVector(y, 2, 0);
    SolveLinearSystemOfEquations(J, b, y, 1);
    W_[193] = GetVector(y, 1);
    W_[237] = GetVector(y, 2);
    EndStaticLinearSystemOfEquations(J);
  }
  W_[122] = helpvar[1]*0.01*W_[237];
  W_[217] = 200000.0*W_[122];
  W_[55] = (-5E-006)*W_[193];
  W_[52] =  -(DP_[25]+W_[55]);
  W_[97] = 1000.0*W_[52];
  W_[428] = DP_[10]-W_[97];
  W_[36] = W_[428]-(W_[193]+W_[392]+W_[217]+W_[237]+DP_[10]);
  W_[28] = 1.25E-006*W_[36];
   /* End of Equation Block */ 

  BreakSectionEnd()
  BreakSectionStart(7);
  { /* Non-linear system of equations to solve. */
    /* Nonlinear system of equations number = 2. */
  /* Introducing 2 common subexpressions used in 2 expressions */
  /* Of the common subexpressions 2 are reals, 0 are integers, and 0
     are booleans. */
  const char*const varnames_[]={"rad.heatPortRad.T"};
  const double nominal_[]={300.0};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 2, 8);
  SetInitVectorSimple(x__, 1, W_[142], 288.15);
  Residues;
    W_[179] = W_[142]-W_[173];
    helpvar[17] = DP_[38]*W_[170]*powmacro(fabs(W_[168]),"abs(rad.dTRad_nominal[1])",
      DP_[41]-1,"rad.n-1");
    W_[184] = helpvar[17]*W_[179];
  helpvar[18] = 1+DP_[50]*(W_[142]-DP_[49]);
  SetVector(residue__, 1,  -W_[184]*helpvar[18]);

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  SetMatrixLeading(Jacobian__, 1, 1, 1,  -(W_[184]*DP_[50]+helpvar[17]*helpvar[18]));

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__);
  W_[142] = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 2);
   /* End of Non-Linear Equation Block */ }



  BreakSectionEnd()
  BreakSectionStart(10);
   /* Linear system of equations to solve. */
  /* Introducing 1 common subexpressions used in 2 expressions */
  /* Of the common subexpressions 1 are reals, 0 are integers, and 0
     are booleans. */
  helpvar[25] = divmacro(1.0,"1.0",W_[246],"val.dp_nominal_pos");
  W_[238] = 0.0;
  SolveScalarLinearParametric(helpvar[25]*(-12010.0)-1.0,"(-12010.0)/val.dp_nominal_pos-1.0",
     W_[393],"der(pump.dp_actual)", W_[238],"der(val.dp)");
  W_[29] = helpvar[25]*0.01*W_[238];
  W_[458] = 800000.0*W_[29];
  W_[218] = 200000.0*W_[29];
  W_[488] = W_[218]+W_[393]+W_[238]+W_[458];
  W_[429] = (-1000.0)*W_[29];
  W_[194] = W_[429]-W_[488];
   /* End of Equation Block */ 

  BreakSectionEnd()
BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionCallNew(5);
BreakSectionFunctionCallNew(6);
BreakSectionFunctionCallNew(8);
BreakSectionFunctionCallNew(9);
BreakSectionFunctionCallNew(11);
BreakSectionFunctionCallNew(12);
BreakSectionFunctionCallNew(13);
BreakSectionFunctionCallNew(14);
BreakSectionFunctionCallNew(15);
BreakSectionFunctionCallNew(16);
BreakSectionFunctionCallNew(17);
BreakSectionFunctionCallNew(18);
BreakSectionFunctionCallNew(19);
BreakSectionFunctionEnd()
