within Annex60.Fluid.Examples.PerformanceExamples;
model Example6 "Example model demonstrating performance of basic equations"
  extends Modelica.Icons.Example;
  parameter Integer nCapacitors = 500;
  parameter Real R = 0.001;
  //  annotation(Evaluate=true);
  parameter Real C = 1000;
  // annotation(Evaluate=true);

  Real[nCapacitors] T;
  Real[nCapacitors+1] Q_flow;
equation
  Q_flow[1]=((273.15+sin(time))-T[1])/R;
  der(T[1])=(Q_flow[1]-Q_flow[2])/C;
  for i in 2:nCapacitors loop
    Q_flow[i] = (T[i-1] - T[i])/R;
    der(T[i])=(Q_flow[i]-Q_flow[i+1])/C;
  end for;
  Q_flow[nCapacitors+1]=0; //adiabatic

  annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-120,
            -40},{40,60}}),    graphics={Text(
          extent={{-62,24},{-18,-4}},
          lineColor={0,0,255},
          textString="See code")}),
    experiment(
      StopTime=100,
      __Dymola_NumberOfIntervals=1,
      __Dymola_fixedstepsize=0.001,
      __Dymola_Algorithm="Euler"),
    __Dymola_experimentSetupOutput,
    Icon(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=
            false)),
    Documentation(revisions="<html>
<ul>
<li>
April 17, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>", info="<html>
<p>This example, together with 
<a href=\"modelica://Annex60/Fluid/Examples/PerformanceExamples/Example7.mo\"> 
Example 7
</a>, 
illustrates the overhead 
generated by divisions by parameters. See the paper for a complementary discussion.
</p>
<p>
Running following commands allows comparing the CPU times of the two models, 
disregarding as much as possible the influence of the integrator:
</p>
<p>
simulateModel(&QUOT;Annex60.Fluid.Examples.PerformanceExamples.Example6&QUOT;, stopTime=100, numberOfIntervals=1, method=&QUOT;Rkfix4&QUOT;, fixedstepsize=0.001, resultFile=&QUOT;Example6&QUOT;);<br />
simulateModel(&QUOT;Annex60.Fluid.Examples.PerformanceExamples.Example7&QUOT;, stopTime=100, numberOfIntervals=1, method=&QUOT;Rkfix4&QUOT;, fixedstepsize=0.001, resultFile=&QUOT;Example7&QUOT;);
</p>
<p>
Comparing the CPUtimes indicates a speed improvement of 56&percnt;. 
This difference almost disappears when adding annotation(Evaluate=true) 
to R and C in Example 6. 
</p>
<p>
In dsmodel.c we find:
</p>
<code>DynamicsSection<br />
W_[2] = divmacro(X_[0]-X_[1],&QUOT;T[1]-T[2]&QUOT;,DP_[0],&QUOT;R&QUOT;);<br />
F_[0] = divmacro(W_[1]-W_[2],&QUOT;Q_flow[1]-Q_flow[2]&QUOT;,DP_[1],&QUOT;C&QUOT;);
</code>
<p>
This suggests that the parameter division needs to be handled during 
each function evaluation, probably causing the increased overhead. 
Setting Evaluate = true removes this overhead.
</p>
</html>"));
end Example6;
